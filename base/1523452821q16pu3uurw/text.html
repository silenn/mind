<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'Georgia'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">События</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Встраиваемые системы реального времени должны предпринимать некоторые действия в ответ на события (<span style=" font-weight:600;">event</span>), приходящие от внешнего окружения. Например пакет, который пришел в периферийное устройство Ethernet (событие) может требовать своей передачи в стек TCP/IP для обработки (действие).</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Сложные системы будут иметь службу событий, которые приходят от разных источников, которые требуют разные процедуры обработки и разные требования к времени реакции. В каждом случае должно быть принято решение для реализации лучшей стратегии обработки события:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1</span>. Как событие должно детектироваться? Обычно используются прерывания, но может также быть применен опрос входов (<span style=" font-weight:600;">polling</span>).</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2</span>. Когда используются прерывания, как много действий по обработке должно быть предпринято внутри обработчика прерывания (<span style=" font-weight:600;">ISR</span>), и как много действий нужно сделать вне обработчика прерывания? Обычно желательно сохранять размер ISR как можно меньше по времени выполнения.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3</span>. Как события должны обмениваться информацией с главным кодом (не ISR), и как этот код должен быть структурирован, чтобы лучше всего совместить обработку потенциально асинхронных процессов?</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">FreeRTOS не предоставляет разработчику приложения никакую специальную стратегию для обработки событий, но дает возможности для реализации выбранной стратегии простым и хорошо поддерживаемым методом.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Всегда помните, что любые функции API и макросы, которые оканчиваются на ‘<span style=" font-weight:600;">FromISR</span>’ или ‘<span style=" font-weight:600;">FROM_ISR</span>’, должны быть всегда использованы внутри обработчика прерывания (interrupt service routine, ISR).</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.2. Обработка отложенных (deferred) прерываний</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Двоичные семафоры, используемые для синхронизации</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Двоичные семафоры могут использоваться для разблокировки задачи каждый раз, когда возникает какое-то отдельное прерывание, чем можно эффективно засинхронизировать задачу с прерыванием. Это позволяет разместить почти весь код обработки события прерывания внутри синхронизированной задачи, оставляя в ISR только очень малую часть кода. Такая обработка прерывания называется 'отложенной' (deferred) для задачи-обработчика события.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если обработка прерывания критична по времени реакции, то приоритет задачи обработки может быть назначен соответственно выше, чтобы обеспечить вытеснение обработчиком других задач в системе. Это произойдет сразу после завершения ISR. В результате достигается эффект обработки всех событий в основном коде, как если бы эта обработка была реализована непосредственно в коде ISR. Такая схема демонстрируется на рисунке 26.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image29730.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 26. Прерывание останавливает одну задачу, при этом делая возврат в другую задачу.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача обработчика использует блокирующий на семафоре вызов '<span style=" font-weight:600;">take</span>' (взять), что подразумевает вхождение в состояние Blocked для ожидания момента события. Когда событие произойдет, ISR использует операцию '<span style=" font-weight:600;">give</span>' (давать) на том же самом семафоре для разблокировки задачи обработчика, чтобы могла произойти требуемая обработка события.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Концепция семафора 'take' (взять) и 'give' (давать) может подразумевать разное, в зависимости от сценария использования. В классической терминологии семафоров 'взять семафор' эквивалентно операции <span style=" font-weight:600;">P()</span>, а 'дать семафор' эквивалентно операции <span style=" font-weight:600;">V()</span>.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В этом сценарии синхронизации прерывания семафор концептуально может считаться очередью с длиной, равной 1. Очередь может содержать максимум один элемент в любой момент времени, так что очередь может быть либо пуста, либо полна (как двоичный флаг может быть либо сброшен, либо установлен, поэтому семафор двоичный). Путем вызова xSemaphoreTake() задача обработчика пытается прочитать из очереди на все время блокировки, что приведет ко входу задачи обработчика в состояние Blocked, если очередь пуста (т. е. событие пока не произошло). Когда событие произойдет, то ISR просто будет использовать функцию xSemaphoreGiveFromISR() для помещения токена (семафора) в очередь, что сделает очередь заполненной. Это приведет к выходу задачи обработчика из состояния Blocked, которая удалит токен, снова очистив очередь. Как только задача обработчика завершит свою обработку, она снова сделает попытку чтения из очереди, найдет очередь пустой и снова войдет в состояние Blocked для ожидания следующего события. Эта последовательность показана на рисунке 27.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">На рисунке 27 видно, что прерывание 'дает' семафор в любом случае, даже если он еще не 'взят', и задача 'берет' семафор, но никогда не отдает его обратно. Поэтому описанный сценарий концептуально эквивалентен записи и чтению через очередь. Это часто вызывает путаницу, поскольку в других семафорных сценариях используются другие правила, где задача, которая берет семафор, должна всегда его отдать - такой сценарий описан в части 4.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">vSemaphoreCreateBinary()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хендлы ко всем различным типам семафоров FreeRTOS сохраняются в переменной типа xSemaphoreHandle.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Перед тем, как семафор можно реально использовать, он должен быть сначала создан. Для создания двоичного семафора используется API функция vSemaphoreCreateBinary().</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Примечание: API семафоров реально реализовано как набор макросов, это не функции. Для упрощения изложения в этой книге эти макросы называются функциями.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vSemaphoreCreateBinary( xSemaphoreHandle xSemaphore );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xSemaphore</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Создаваемый семафор</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Имейте в виду, что vSemaphoreCreateBinary() в действительности реализована как макрос, так что переменная должна быть передана напрямую, а не через указатель. Пример в этой части включает вызовы vSemaphoreCreateBinary(), которые могут быть скопированы в качестве образца.</p></td></tr></table>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image25964.png" /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image10763.png" /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image26651.png" /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image25627.png" /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image24216.png" /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 27. Использование двоичного семафора для синхронизации задачи и прерывания.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">xSemaphoreTake()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">'Взять' (Take) семафор означает 'получить' или 'принять' семафор. Семафор можно взять только если он доступен. В классической терминологии семафоров xSemaphoreTake() эквивалентна операции P().</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Все различные типы семафоров FreeRTOS, за исключением рекурсивных семафоров, могут быть 'взяты' с использованием функции xSemaphoreTake().</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">xSemaphoreTake() нельзя использовать из ISR.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">portBASE_TYPE xSemaphoreTake( xSemaphoreHandle xSemaphore, portTickType xTicksToWait );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Таблица 13. Параметры и значение возврата функции xSemaphoreTake().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра<br />/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xSemaphore</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Семафор, который надо 'взять'.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">К семафору происходит обращение через переменную xSemaphoreHandle, и семафор должен быть явно создан перед тем, как его можно использовать.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xTicksToWait</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Максимальное время, в котором задача должна оставаться в состоянии Blocked при ожидании семафора, если он еще недоступен.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если xTicksToWait равен 0, то xSemaphoreTake() сделает возврат немедленно, если семафор недоступен.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Время блокировки указана в периодах тика, так что абсолютное представленное время зависит от частоты тиков. Можно использовать константу portTICK_RATE_MS для преобразования указанного времени в миллисекундах во время, указанное в тиках.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Установка xTicksToWait в значение portMAX_DELAY приведет к тому, что задача будет бесконечно (без таймаута) ожидать семафора, если в файле FreeRTOSConfig.h INCLUDE_vTaskSuspend установлена в 1.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Возможны два возвращаемых значения:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">pdPASS - будет возвращено только в том случае, если xSemaphoreTake() успешно получила семафор.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если указано время блокировки (xTicksToWait не равно 0), то возможна ситуация, что задача перешла в состояние Blocked для ожидания семафора (если он не был доступен), но семафор стал доступен до истечения указанного времени блокировки.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">pdFALSE - семафор недоступен.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если указано время блокировки (xTicksToWait не равно 0), то вызвавшая функцию задача перешла в состояние Blocked для ожидания доступности семафора, но семафор так и не стал доступен после истечения указанного времени блокировки.</p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">xSemaphoreGiveFromISR()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Все различные типы семафоров FreeRTOS, за исключением рекурсивных семафоров, могут быть 'выданы' с использованием функции xSemaphoreGiveFromISR().</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">xSemaphoreGiveFromISR() - специальная форма функции xSemaphoreGive(), которая специально предназначена для использования из ISR.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">portBASE_TYPE xSemaphoreGiveFromISR( xSemaphoreHandle xSemaphore,<br />                                     portBASE_TYPE *pxHigherPriorityTaskWoken );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Таблица 14. Параметры и значение возврата функции xSemaphoreGiveFromISR()</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра<br />/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xSemaphore</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Семафор, который надо 'дать'.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">К семафору происходит обращение через переменную xSemaphoreHandle, и семафор должен быть явно создан перед тем, как его можно использовать.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">pxHigherPriorityTaskWoken</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Возможен случай, что один и тот же семафор будет блокировать одну или большее количество задач на ожидании доступности семафора. Вызов xSemaphoreGiveFromISR() может сделать семафор доступным, так что это приведет к выходу таких задач из состояния Blocked. Если вызов xSemaphoreGiveFromISR() привел к выходу задачи из состояния Blocked, и у разблокированной задачи приоритет выше, чем у текущей выполняющейся задачи, (задача, которая была остановлена ISR прерывания), то xSemaphoreGiveFromISR() установит внутри себя *pxHigherPriorityTaskWoken в значение pdTRUE.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если xSemaphoreGiveFromISR() установит это значение в pdTRUE, то должно быть выполнено переключение контекста перед выходом из ISR. Это приведет к тому, что выход из ISR будет произведен сразу прямо в задачу с наивысшим приоритетом, находящуюся в состояние Ready.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Возможны два возвращаемых значения:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">pdPASS - будет возвращено только в том случае, если вызов xSemaphoreGiveFromISR() был успешным.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">pdFAIL - если семафор уже доступен, он не может быть предоставлен, и xSemaphoreGiveFromISR() вернет pdFAIL.</p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Пример 12. Использование двоичного семафора для синхронизации задачи с прерыванием</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот пример использует двоичный семафор для разблокировки задачи их обработчика прерывания (ISR) - чем достигается эффективная синхронизация задачи с прерыванием.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Простая периодическая задача используется для генерации программного прерывания (software interrupt) каждые 500 миллисекунд. Программное прерывание используется для удобства, потому что трудно отслеживать реальные прерывания IRQ от эмулированного DOS-окружения. Листинг 44 показывает реализацию периодической задачи. Имейте в виду, что задача печатает строку перед и после генерации прерывания. Это позволяет явно продемонстрировать в выводе последовательность выполнения приложения.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vPeriodicTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Эта задача используется просто для 'симуляции' прерывания,<br />        генерируемого через программное прерывание каждые 500 мс. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskDelay( 500 / portTICK_RATE_MS );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Генерация прерывания, печать в консоль сообщения до и после<br />        последовательности,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">так что последовательность выполнения<br />        хорошо видна при выполнении примера. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Periodic task - About to generate an interrupt.\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />     __asm{ </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> 0x82 } </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Эта строка генерирует прерывание. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Periodic task - Interrupt generated.\r\n\r\n\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 45 показывает реализацию задачи обработчика - задача, которая синхронизирована с программным прерыванием через использование двоичного семафора. Снова сообщение выводится на печать при каждой итерации задачи, так что последовательность, в котором выполняются задача и прерывание, хорошо видна при выполнении примера.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 45. Реализация задачи обработчика (handler task), т. е. задачи, которая засинхронизирована с прерыванием, в примере 12:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vHandlerTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Как и большинство задач, эта задача реализована на основе бесконечного<br />     цикла. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Использование семафора для ожидания события. Семафор был создан перед<br />        запуском шедулера, т. е. перед тем, как эта задача была запущена<br />        в первый раз. Задача блокируется на бесконечное время, так что<br />        возврат из функции xSemaphoreTake()</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">произойдет только после успешного<br />        'взятия' (получения) семафора. Таким образом, здесь не нужно<br />        проверять результат возврата функции xSemaphoreTake(). */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xSemaphoreTake( xBinarySemaphore, portMAX_DELAY );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Чтобы управление попало сюда, должно было произойти прерывание.<br />        В этом месте кода обычно стоит обработка события, в нашем же случае<br />        вся обработка заключается</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">в простом выводе сообщения. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Handler task - Processing event.\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 46 показывает реальный обработчик прерывания ISR. Он выполняет очень мало действий, кроме как 'выдает' семафор для разблокировки задачи обработчика. Обратите внимание, как используется параметр pxHigherPriorityTaskWoken. Он устанавливается в значение pdFALSE перед вызовом xSemaphoreGiveFromISR(), с выполнением переключения контекста, если впоследствии было обнаружено, что pxHigherPriorityTaskWoken равно pdTRUE.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Синтаксис определения ISR и вызов макроса для переключения контекста привязан к специфической платформе порта Open Watcom DOS, и может отличаться от других портов. Пожалуйста обратитесь к примерам, которые включены в демо-приложения для используемого Вами порта FreeRTOS, чтобы найти актуальный, требуемый для Вашего порта синтаксис.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> __interrupt __far vExampleInterruptHandler( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> portBASE_TYPE xHigherPriorityTaskWoken;<br />  xHigherPriorityTaskWoken = pdFALSE;<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* 'Дать' семафор для разблокировки задачи. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xSemaphoreGiveFromISR( xBinarySemaphore, &amp;xHigherPriorityTaskWoken );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xHigherPriorityTaskWoken == pdTRUE )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Выдача семафора разблокирует задачу, и приоритет разблокированной</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        задачи выше, чем у текущей выполняющейся задачи - поэтому контекст</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        выполнения переключается принудительно в разблокированную (с более<br />        высоким приоритетом) задачу.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        ВНИМАНИЕ: макрос, реально используемый для переключения контекста<br />        из ISR, зависит от конкретного порта FreeRTOS. Здесь указано<br />        имя макроса, корректное для порта Open Watcom DOS. Другие порты<br />        FreeRTOS могут использовать другой синтаксис. Для определения<br />        используемого синтаксиса обратитесь к примерам, предоставленным<br />        вместе с портом FreeRTOS. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     portSWITCH_CONTEXT();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция main() просто создает двоичный семафор и задачи, инсталлирует обработчик прерывания и запускает шедулер. Реализация показана в листинге 47.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> main( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Перед использованием семафор должен быть явно создан. В этом примере</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     создается двоичный семафор. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  vSemaphoreCreateBinary( xBinarySemaphore );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Инсталляция обработчика прерывания ISR. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  _dos_setvect( 0x82, vExampleInterruptHandler );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Поверка - успешно ли создан семафор. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xBinarySemaphore != NULL )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание задачи обработчика. Это задача, которая засинхронизирована с</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        прерыванием (ISR). Задача обработчика создается с самым высоким</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        приоритетом, чтобы обеспечить его немедленный запуск после выхода</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        из ISR. В нашем случае выбран приоритет 3. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( vHandlerTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Handler&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, NULL, 3, NULL );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание задачи, которая будет периодически генерировать программное</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        прерывание. Задача создается с приоритетом меньшим, чем задача</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        обработчика, чтобы обеспечить вытеснение задачей обработчика,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        когда задача обработчика выходит из состояния Blocked. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( vPeriodicTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Periodic&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, NULL, 1, NULL );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Запуск шедулера, после чего задачи запустятся на выполнение. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskStartScheduler();<br />  }<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Если все хорошо, то управление в main() никогда не дойдет до этой точки,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     и теперь шедулер будет управлять задачами. Если main() довела управление<br />     до</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">этого места, то это может означать, что не хватает памяти кучи (heap)</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     для создания специальной задачи ожидания (idle task, об этой задаче<br />     далее).</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Часть 5 предоставляет больше информации по управлению памятью. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; );<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Пример 12 производит вывод, показанный на рисунке 28. Как и ожидалось, задача обработчика (Handler) запускается немедленно после генерации прерывания (Interrupt), так что вывод из задачи обработчика делит на части вывод, производимый периодической задачей (Periodic). Более подробно процесс описан на рисунке 29.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image9386.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 28. Вывод, который производит при выполнении пример 12</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1258.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 29. Последовательность выполнения примера 12</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.3. Семафоры со счетчиком</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Пример 12 продемонстрировал двоичный семафор, который использовался для синхронизации задачи с прерыванием. Последовательность выполнения была следующей:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1</span>. Происходит прерывание.<br /><span style=" font-weight:600;">2</span>. Запускается ISR, 'выдает' семафор для разблокировки задачи обработчика.<br /><span style=" font-weight:600;">3</span>. Задача обработчика сразу запускается после завершения ISR. Первое, что задача обработчика делает - она 'берет' семафор.<br /><span style=" font-weight:600;">4</span>. Задача обработчика выполняет обработку события перед новой попыткой 'взять' семафор - и входит в состояние Blocked, если семафор еще недоступен.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот сценарий хорошо подходит для случая, когда прерывания могут произойти только с относительно низкой частотой. Если же произойдет другое прерывание до того, как задача обработчика завершит свою обработку первого захваченного семафором события, то двоичный семафор эффективно фиксировал бы событие, позволяя задаче обработчика немедленно обработать новое событие после обработки предыдущего. Задача обработчика не вошла бы в состояние Blocked между обработкой этих двух событий, так как фиксируемый семафор был бы доступен сразу, как только произойдет вызов xSemaphoreTake(). Этот случай показан на рисунке 30.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image20869.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image11318.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image7137.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image9483.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image18708.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image27626.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 30. Двоичный семафор может фиксировать не больше одного события</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рисунок 30 демонстрирует, что двоичный семафор может захватить самое бОльшее только одно событие прерывания. Все последующие события, произошедшие перед обработкой уже захваченного события, будут потеряны. Этого можно избежать, если использовать семафор со счетчиком вместо двоичного семафора.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Так же, как двоичные семафоры можно концептуально сопоставить с очередями, длина которых равна 1, семафоры со счетчиком можно представить как очереди, длина которых больше 1. Задачам не интересны данные, которые сохранены в такой очереди - им просто нужно знать, пуста очередь или нет.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Каждый раз, когда семафору со счетчиком 'дают', в его очереди задействуется пространство (очередь становится непустой). Количество элементов (событий) в очереди показывает значение счетчика семафора.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image3304.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image12773.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image25496.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image13714.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image26168.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image21441.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 31. Использование семафора-счетчика для 'подсчета' событий.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Семафоры со счетчиком обычно используют в следующих случаях:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1</span>. Подсчет событий. В этом сценарии использования ISR 'выдает' семафор каждый раз, когда происходит событие - что инкрементирует значение счетчика семафора при каждой выдаче семафора. Задача обработчика события будет 'брать' семафор каждый раз, когда она обрабатывает событие - что будет декрементировать счетчик семафора при каждом получении семафора. Значение счетчика семафора отражает разницу между количеством произошедших событий и количеством уже обработанных событий. Этот механизм показан на рисунке 31.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Семафоры со счетчиком, используемые для подсчета событий, создаются с начальным значением счетчика, равным 0.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2</span>. Управление ресурсами. В этом сценарии использования значение счетчика показывает количество доступных ресурсов. Для получения контроля над ресурсом задача должна сначала получить семафор - и этим уменьшить значение счетчика семафора. Когда значение счетчика семафора станет равным 0, то это будет означать, что больше нет свободных ресурсов. Когда задача завершает работу с ресурсом, она 'выдает' семафор обратно - увеличивая значение счетчика семафора.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Семафоры со счетчиком, которые используются для управления ресурсами, создаются с начальным значением счетчика, равным количеству доступных ресурсов. В части 4 рассматривается использование семафоров для управления ресурсами.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">xSemaphoreCreateCounting()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хендлы ко всем различным типам семафоров FreeRTOS сохраняются в переменной типа xSemaphoreHandle.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Перед тем, как семафор можно реально использовать, он должен быть сначала создан. Для создания семафора со счетчиком используется API функция xSemaphoreCreateCounting().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">xSemaphoreHandle xSemaphoreCreateCounting<br />                     ( unsigned portBASE_TYPE uxMaxCount,<br />                       unsigned portBASE_TYPE uxInitialCount );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Таблица 15. Параметры и значение возврата функции xSemaphoreCreateCounting().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра<br />/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">uxMaxCount</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Максимальное значение, до которого будет считать семафор. Чтобы продолжить аналогию с очередью, значение uxMaxCount соответствует длине очереди.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда семафор начинают использовать для подсчета или захвата событий, uxMaxCount будет максимальным количеством событий, которое можно захватить.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда семафор используется для управления доступом к набору ресурсов, uxMaxCount должно быть установлено в максимальное количество доступных ресурсов.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">uxInitialCount</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Начальное значение счетчика семафора после того как он был создан.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда семафор используется для подсчета или захвата событий, uxInitialCount должно быть установлено в 0 - подразумевается, что в момент создания семафора еще не наступило ни одно событие.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда семафор используется для управления доступом к набору ресурсов, то uxInitialCount должно быть установлено в значение, равное uxMaxCount - подразумевается, что в момент создания семафора имеются в наличии все доступные ресурсы.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если функция вернула NULL, то семафор не создан, так как в куче (heap) FreeRTOS недостаточно свободного места для выделения памяти под структуры данных семафора. Часть 5 предоставляет больше информации по управлению памятью.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если функция вернула не NULL, то семафор создан успешно. Возвращенное значение нужно сохранить как хендл семафора для его дальнейшего использования.</p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Пример 13. Использование считающего семафора для синхронизации задачи с прерыванием</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Пример 13 улучшает реализацию примера 12 путем использования семафора со счетчиком вместо двоичного семафора. Функция main() изменена для использования вызова xSemaphoreCreateCounting() вместо vSemaphoreCreateBinary(). Вызов новой API функции показан в листинге 49.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Перед использованием семафора он должен быть явно создан. В этом примере</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   создается семафор со счетчиком. Семафор создается для максимального<br />   значения</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">счета 10, и начальным значением счетчика 0. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />xCountingSemaphore = xSemaphoreCreateCounting( 10, 0 );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Для симуляции возникновения нескольких событий с высокой частотой изменена подпрограмма обработчика прерывания ISR, чтобы 'выдавать' семафор больше одного раза за одно прерывание. Каждое событие захватывается в значении счетчика семафора. Измененная ISR показана в листинге 50.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> __interrupt __far vExampleInterruptHandler( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> portBASE_TYPE xHigherPriorityTaskWoken;<br /><br />  xHigherPriorityTaskWoken = pdFALSE;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* 'Выдача' семафора несколько раз. Первая выдача разблокирует задачу<br />     обработчика</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">следующие выдачи демонстрируют, как семафор захватывает<br />     события, чтобы позволить задаче обработчика обработать их друг за<br />     другом, и не потерять ни одного события. Это симулирует появление<br />     нескольких прерываний, полученных процессором,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">несмотря на то, что в этом<br />    случае события симулируются внутри одного возникшего прерывания. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xSemaphoreGiveFromISR( xCountingSemaphore, &amp;xHigherPriorityTaskWoken );<br />  xSemaphoreGiveFromISR( xCountingSemaphore, &amp;xHigherPriorityTaskWoken );<br />  xSemaphoreGiveFromISR( xCountingSemaphore, &amp;xHigherPriorityTaskWoken );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xHigherPriorityTaskWoken == pdTRUE )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Выдача семафора разблокировала задачу, и приоритет разблокированной</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        задачи выше, чем у текущей задачи - принудительно переключаем<br />        контекст</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">выполнения, чтобы обеспечить возврат из ISR напрямую<br />        в разблокированную (которая имеет самый высокий приоритет) задачу.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        ВНИМАНИЕ: макрос, реально используемый для переключения контекста<br />        из ISR,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">зависит от конкретного порта FreeRTOS. Здесь указано имя<br />        макроса, корректное для порта Open Watcom DOS. Другие порты FreeRTOS<br />        могут</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">использовать другой синтаксис. Для определения используемого<br />        синтаксиса обратитесь к примерам, предоставленным вместе с портом<br />        FreeRTOS. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     portSWITCH_CONTEXT();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Все остальные функции остались неизменными, как в примере 12.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Вывод, производимый примером 13, показан на рисунке 32. Как можно увидеть, задача обработчика обрабатывает все три (симулированные) события каждый раз, когда генерируется прерывание. События захватываются с значении счетчика семафора, что позволяет задаче обработчика обработать все события друг за другом.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image19929.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.4. Использование очередей внутри обработчика прерывания (ISR)</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функции xQueueSendToFrontFromISR(), xQueueSendToBackFromISR() и xQueueReceiveFromISR() являются защищенными версиями функций xQueueSendToFront(), xQueueSendToBack() и xQueueReceive() соответственно, которые можно безопасно использовать в коде ISR.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Семафоры используются для передачи сообщений (из ISR в основную программу). Очереди используются как для передачи сообщений, так и для передачи данных (из ISR в основную программу).</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функции <span style=" font-weight:600;">xQueueSendToFrontFromISR()</span> и <span style=" font-weight:600;">xQueueSendToBackFromISR()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">xQueueSendFromISR() является эквивалентной и полностью соответствует xQueueSendToBackFromISR().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прототип API функции xQueueSendToFrontFromISR():</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">portBASE_TYPE xQueueSendToFrontFromISR<br />                   ( xQueueHandle xQueue,<br />                     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvItemToQueue<br />                     portBASE_TYPE *pxHigherPriorityTaskWoken );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прототип API функции xQueueSendToBackFromISR():</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">portBASE_TYPE xQueueSendToBackFromISR<br />                   ( xQueueHandle xQueue,<br />                     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvItemToQueue<br />                     portBASE_TYPE *pxHigherPriorityTaskWoken );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Таблица 16. Параметры и значение возврата функций xQueueSendToFrontFromISR() и xQueueSendToBackFromISR().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра<br />/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xQueue</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Хендл очереди, в которую данные посылаются (записываются). Хендл очереди берут из значения, которое вернула функция xQueueCreate() при создании очереди.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">pvItemToQueue</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Указатель на данные, которые будут скопированы в очередь.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Размер каждого элемента очереди, который она может хранить, устанавливается при создании очереди, таким образом это количество байт будет скопировано из памяти по указателю pvItemToQueue в область хранения данных, принадлежащую очереди.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">pxHigherPriorityTaskWoken</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Возможен случай, что одна и та же очередь будет блокировать одну или большее количество задач на ожидании доступности данных. Вызов xQueueSendToFrontFromISR() или xQueueSendToBackFromISR() может сделать данные доступными, так что это приведет к выходу таких задач из состояния Blocked. Если вызов функции привел к выходу задачи из состояния Blocked, и у разблокированной задачи приоритет выше, чем у текущей выполняющейся задачи, (задача, которая была прервана ISR), то функция установит внутри себя *pxHigherPriorityTaskWoken в значение pdTRUE.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если xQueueSendToFrontFromISR() или xQueueSendToBackFromISR() установит это значение в pdTRUE, то должно быть выполнено переключение контекста выполнения перед выходом из ISR. Это приведет к тому, что выход из ISR будет произведен сразу прямо в задачу с наивысшим приоритетом, находящуюся в состояние Ready.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Возможны два возвращаемых значения:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">pdPASS - будет возвращено только в том случае, когда данные были успешно отправлены в очередь.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">errQUEUE_FULL - если данные не были отправлены в очередь, так как очередь уже полна.</p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Эффективное использование очереди</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Большинство демо-приложений, включенных в загружаемый пакет FreeRTOS, включают в себя простой драйвер UART, который использует очереди для передачи символов в обработчик прерывания передачи и для передачи символов из обработчика прерывания приема. Каждый символ, который был отправлен или принят, индивидуально передается через очередь. Драйверы UART реализованы таким способом только для того, чтобы продемонстрировать использование очереди изнутри ISR. Индивидуальная передача символов через очередь чрезвычайно неэффективна (особенно для высоких скоростей), и не рекомендуется для рабочего кода готовых изделий. Более эффективная техника включает в себя следующее:</p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Размещение каждого принятого символа в простейший буфер RAM, который использует семафор для разблокировки задачи, обрабатывающей буфер после полного приема сообщения, или после детектирования в потоке признака break.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Интерпретация принятых символов прямо в ISR, тогда очередь используется для отправки интерпретированных и декодированных команд, которые будут обработаны в последствии разблокированной задачей (точно так же, как показано на рисунке 23). Эта техника подходит только тогда, когда интерпретация потока данных достаточно быстрая, чтобы быть выполненной полностью внутри ISR.</li></ul>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Пример 14. Отправка и прием на очереди с использованием прерывания</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот пример демонстрирует использование xQueueSendToBackFromISR() и xQueueReceiveFromISR() внутри одного и того же прерывания. Как и было ранее, для удобства в примере используется программное прерывание.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В примере создается периодическая задача, которая отправляет пять чисел в очередь каждые 200 миллисекунд. Она генерирует программное прерывание только после того, как все пять значений будут отправлены. Реализация задачи показана в листинге 53.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vIntegerGenerator( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br />portTickType xLastExecutionTime;<br />unsigned portLONG ulValueToSend = 0;<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> i;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Инициализация переменной, используемой в вызове vTaskDelayUntil(). */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xLastExecutionTime = xTaskGetTickCount();<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Это периодическая задача. Блокировка до времени, когда нужно будет</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        запуститься снова. Задача будет запускаться каждые 200 мс. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskDelayUntil( &amp;xLastExecutionTime, 200 / portTICK_RATE_MS );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Отправка инкрементируемого числа в очередь пять раз. Значения будут</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        прочитаны из очереди внутри ISR. ISR всегда опустошит очередь, так</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        что гарантируется, что эта задача будет в состоянии записать<br />        в очередь все пять значений числа, так что время блокировки<br />        не требуется. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( i = 0; i &lt; 5; i++ )<br />     {<br />         xQueueSendToBack( xIntegerQueue, &amp;ulValueToSend, 0 );<br />         ulValueToSend++;<br />     }<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Принудительно инициализируем прерывание, так чтобы сработавшая ISR</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        могла прочитать значения из очереди. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Generator task - About to generate an interrupt.\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />     __asm{ </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> 0x82 } </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Эта строка генерирует прерывание. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Generator task - Interrupt generated.\r\n\r\n\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">ISR делает повторы вызовов xQueueReceiveFromISR() до тех пор, пока не будут удалены из очереди все значения, записанные в неё, т. е. пока очередь не станет пустой. Последние два бита каждого принятого значения используются как индекс в массиве строк, и указатель на строку в соответствующей индексной позиции будет отправлен в другую очередь с использованием вызова xQueueSendFromISR(). Реализация ISR показана в листинге 54.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> __interrupt __far vExampleInterruptHandler( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> portBASE_TYPE xHigherPriorityTaskWoken;<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> unsigned </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> ulReceivedNumber;<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Строки декларируется как static const, чтобы они не были</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   размещены в стеке ISR, и существовали всегда, даже когда</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   ISR не выполняется. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pcStrings[] =<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;String 0\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">,<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;String 1\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">,<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;String 2\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">,<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;String 3\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />};<br /><br />  xHigherPriorityTaskWoken = pdFALSE;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Цикл до полного опустошения очереди. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">while</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xQueueReceiveFromISR( xIntegerQueue,<br />                                &amp;ulReceivedNumber,<br />                                &amp;xHigherPriorityTaskWoken ) != errQUEUE_EMPTY )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Обрезка принятого значения, чтобы оставить только последние два бита</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        (значения от 0 до 3), затем отправка в другую очередь указателя<br />        на строку, которая соответствует обрезанному значению. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     ulReceivedNumber &amp;= 0x03;<br />     xQueueSendToBackFromISR( xStringQueue,<br />                              &amp;pcStrings[ ulReceivedNumber ],<br />                              &amp;xHigherPriorityTaskWoken );<br />  }<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Мы сделали чтение очереди и отправку через другую очередь, что должно</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     разблокировать задачу, которая имеет приоритет выше, чем та, что работала</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     до вызова ISR? Если это так, то здесь делаем принудительное переключение</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     контекста выполнения. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xHigherPriorityTaskWoken == pdTRUE )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* ВНИМАНИЕ: макрос, реально используемый для переключения контекста<br />        из ISR, зависит от конкретного порта FreeRTOS. Здесь указано<br />        имя макроса,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">корректное для порта Open Watcom DOS. Другие порты<br />        FreeRTOS могут использовать другой синтаксис. Для определения<br />        используемого синтаксиса обратитесь к примерам, предоставленным<br />        вместе с портом FreeRTOS. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     portSWITCH_CONTEXT();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача, которая принимает указатели на строки из ISR, просто блокируется на очереди, до того момента, как в очереди появится сообщение (указатель на строку), и печатает каждую строку, как она была принята. Реализация принимающей строки задачи показана в листинге 55.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vStringPrinter( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pcString;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Блокировка на очереди для ожидания поступления данных. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xQueueReceive( xStringQueue, &amp;pcString, portMAX_DELAY );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Вывод на печать принятой строки. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vPrintString( pcString );<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Как обычно, функция main() создает требуемые очереди и задачи перед запуском шедулера. Её реализация показана в листинге 56.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> main( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Перед тем, как очередь можно использовать, она должна быть сначала<br />     создана.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Создание обоих очередей, используемых в этом примере. Одна<br />     очередь может</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">сохранять переменные типа unsigned long, другая может<br />     сохранять указатели на строки (тип char*). Обе очереди могут запоминать<br />     максимум 10 элементов.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Реальное приложение должно проверять значение<br />     возврата функции xQueueCreate, чтобы убедиться, что очереди были<br />     успешно созданы. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xIntegerQueue = xQueueCreate( 10, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">sizeof</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( unsigned </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> ) );<br />  xStringQueue = xQueueCreate( 10, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">sizeof</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * ) );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Установка обработчика прерывания. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  _dos_setvect( 0x82, vExampleInterruptHandler );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание задачи, которая использует очередь для передачи целых чисел<br />     в ISR. Эта задача создается с приоритетом 1. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xTaskCreate( vIntegerGenerator, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;IntGen&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, NULL, 1, NULL );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание задачи, выводит на печать строки, отправленные из ISR.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     Эта задача создается с самым высоким приоритетом 2. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xTaskCreate( vStringPrinter, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;String&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, NULL, 2, NULL );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Запуск шедулера, после чего созданные задачи начнут выполняться. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  vTaskStartScheduler();<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Если все хорошо, то управление в main() никогда не дойдет до этой точки,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     и теперь шедулер будет управлять задачами. Если main() довела управление<br />     до этого места, то это может означать, что не хватает памяти кучи (heap)</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     для создания специальной задачи ожидания (idle task, об этой задаче<br />     далее). Часть 5 предоставляет больше информации по управлению<br />     памятью. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; );<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Вывод, производимый примером 14, показан на рисунке 33. Как можно увидеть, ISR принимает 5 целых чисел и в ответ производит 5 строк. Более подробно процесс рассматривается на рисунке 34.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image19136.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image6218.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.5. Вложенные прерывания</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Свежие порты FreeRTOS позволяет вложенность прерываний, т. е. во время работы одного ISR может сработать другое прерывание, и будет запущен другой ISR (это называется вложенность прерываний друг в друга). Эти порты требуют одной или двух констант, заданных в хедере FreeRTOSConfig.h. Константы описаны в таблице 17.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#6a1009;">Примечание переводчика: к сожалению, в настоящее время (октябрь 2011 года, FreeRTOSv7.0.2) поддержка констант configKERNEL_INTERRUPT_PRIORITY и configMAX_SYSCALL_INTERRUPT_PRIORITY есть только на небольшом количестве платформ (например на Atmel ARM7 этого пока нет, хотя архитектура позволяет назначать приоритеты аппаратных прерываний). Среди портов, которые содержат установку configKERNEL_INTERRUPT_PRIORITY, имеются пока только Cortex-M3, PIC24, dsPIC, PIC32, SuperH и RX600. Среди портов, которые содержат установку configMAX_SYSCALL_INTERRUPT_PRIORITY, имеются пока только PIC32, RX600 и Cortex M3.</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Таблица 17. Константы, управляющие вложенностью прерываний.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Константа<br /></span></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание<br /></span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">configKERNEL_INTERRUPT_PRIORITY</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Установка приоритета прерывания, используемого для тиков FreeRTOS.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если порт не использует константу configMAX_SYSCALL_INTERRUPT_PRIORITY, то любое прерывание, которое использует защищенные для прерывания функции FreeRTOS API, должно также выполняться с этим приоритетом.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">configMAX_SYSCALL_INTERRUPT_PRIORITY</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Устанавливает наивысший приоритет, из которого могут быть вызваны защищенные для прерываний функции FreeRTOS API.</span></p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Модель полной поддержки вложенности прерываний создается путем установки configMAX_SYSCALL_INTERRUPT_PRIORITY в приоритет выше, чем configKERNEL_INTERRUPT_PRIORITY. Это демонстрируется на рисунке 35, который показывает гипотетический сценарий, где configMAX_SYSCALL_INTERRUPT_PRIORITY установлено в значение 3, и configKERNEL_INTERRUPT_PRIORITY установлено в 1. Как показано, эквивалентный гипотетический микроконтроллер имеет семь разных уровней приоритета. Значение 7 - просто произвольное число для этого гипотетического примера, и оно вовсе не означает, что будет представлено в какой-то конкретной архитектуре микроконтроллера.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image16613.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Комментарии:</p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прерывания, которые используют приоритеты от 1 до 3 включительно, не смогут запуститься (будут отложены) на время выполнения ядра FreeRTOS или на время выполнения кода в пределах критических секций приложения. Однако эти прерывания могут свободно использовать (защищенные для прерываний версии) вызовы функций API FreeRTOS.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">На прерывания, которые используют уровень 4 и выше, никак не влияют критические секции, и никакие действия ядра FreeRTOS не могут повлиять на немедленный запуск этих прерываний - за исключением ограничений только самого микроконтроллера (как если бы FreeRTOS вообще не существовало). Обычно функциональность, необходимая для очень высокой точности времени выполнения (например, для управления двигателем), использует приоритет для ISR выше configMAX_SYSCALL_INTERRUPT_PRIORITY, чтобы гарантировать, что выполнение шедулера не приведет к дрожанию времени отклика прерываний.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прерывания, которые не делают никаких вызовов функций FreeRTOS API, могут свободно использовать любой приоритет прерываний.</li></ul>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Примечание для пользователей ARM Cortex M3</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Микроконтроллеры Cortex M3 используют обратную нумерацию приоритетов прерывания - приоритет с низким числовым номером логически соответствует высокому приоритету прерывания. Это кажется парадоксальным, и об этом легко забыть! Если хотите назначить прерыванию низкий приоритет, то Вы должны назначить ему бОльшее числовое значение приоритета. Не назначайте ему приоритет 0 (или другое число с малым значением), так как в результате прерывание получит самый высокий приоритет в системе 0 - и таким образом потенциально может привести систему к полному отказу, если приоритет прерывания окажется выше configMAX_SYSCALL_INTERRUPT_PRIORITY.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Самый низкий приоритет в ядре Cortex M3 равен 255, хотя разные поставщики ядер Cortex M3 реализуют разное количество бит приоритета и предоставляют функции библиотек, которые рассчитаны на указание приоритетов разными способами. Например, для STM32 самый низкий приоритет может быть указан в библиотеке драйвера ST как 15, а самый высокий приоритет может быть указан как 0.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">123</p></body></html>