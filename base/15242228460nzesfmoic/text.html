<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'Georgia'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">5.1. Введение</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Ядро <span style=" font-weight:600;">FreeRTOS</span> динамически выделяет <span style=" font-weight:600;">RAM</span> всякий раз, когда создается задача, очередь или семафор. Могут использоваться стандартные библиотечные функции <span style=" font-weight:600;">malloc()</span> и <span style=" font-weight:600;">free()</span>, но могут произойти одна или несколько следующих проблем:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1</span>. Функции malloc() и free() не всегда доступны в малых встраиваемых системах.<br /><span style=" font-weight:600;">2</span>. Их реализации могут быть относительно велики, что займет ценное место, которое можно было бы использовать для кода приложения.<br /><span style=" font-weight:600;">3</span>. Они редко бывают защищенными для использования с потоками (no thread-safe).<br /><span style=" font-weight:600;">4</span>. Они не детерминированы (<span style=" font-weight:600;">deterministic</span>). Время выполнения этих функций может отличаться от одного вызова к другому.<br /><span style=" font-weight:600;">5</span>. Они могут привести к фрагментации памяти.<br /><span style=" font-weight:600;">6</span>. Они могут усложнить конфигурацию линкера.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Разные встроенные системы имеют разные требования выделению RAM и характеристикам времени, поэтому один алгоритм выделения RAM подойдет только к некоторому подмножеству приложений. Поэтому <span style=" font-weight:600;">FreeRTOS</span> рассматривает выделение памяти как часть слоя переносимости (в противоположность к базовому коду ядра). Это позволяет отдельным приложениям предоставить свою собственную подходящую специфическую реализацию.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда ядру требуется RAM, оно вместо вызова напрямую malloc() вызывает функцию <span style=" font-weight:600;">pvPortMalloc()</span>. Когда RAM освобождается, оно вместо вызова free() вызывает <span style=" font-weight:600;">vPortFree()</span>. Функция pvPortMalloc() имеет тот же самый прототип, как и malloc(), и vPortFree() имеет такой же прототип, как и free().</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">FreeRTOS поставляется с тремя реализациями примеров для pvPortMalloc() и vPortFree(), все они документированы в этой части. Пользователи FreeRTOS могут использовать одну из этих реализаций, или предоставить свою собственную.<br />Эти три примера заданы в файлах heap_1.c, heap_2.c и heap_3.c соответственно - все они размещены в папке FreeRTOS\Source\Portable\MemMang. Оригинальная схема пула памяти и выделения блока, используемая в очень ранних версиях FreeRTOS, была удалена, так как она требовала усилий в понимании требуемых размеров блока и пула.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Для встраиваемых систем общим случаем является только создание задач, очередей и семафоров перед запуском шедулера. Когда дело обстоит так, память будет динамически выделена перед тем, как приложение начнет выполнять любую функциональность реального времени, и память, выделенная единожды, никогда не будет снова освобождена. Это означает, что выбранная схема выделения не должна рассматривать ни одну из более сложных проблем, такие как детерминизм и фрагментация, и вместо этого нужно только рассмотреть атрибуты, касающиеся простоты и размера кода.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">5.2. Примеры схем выделения памяти</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Heap_1.c</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Модуль Heap_1.c реализует самую минимальную по возможностям версию pvPortMalloc(), и не реализует vPortFree(). Любые приложения, которые не удаляют задачи, очереди или семафоры, могут потенциально использовать heap_1. Heap_1 всегда является детерминированным. Другими словами, память для нужд FreeRTOS распределяется только один раз, в самом начале - при инициализации, и далее во время работы схема распределения памяти не изменяется.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Схема выделения просто подразделяет обычный массив на блоки меньшего размера в качестве вызова pvPortMalloc(). Массив представляет из себя кучу (<span style=" font-weight:600;">heap</span>) FreeRTOS.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Общий объем массива (в байтах) устанавливается определением <span style=" font-weight:600;">configTOTAL_HEAP_SIZE</span> в файле <span style=" font-weight:600;">FreeRTOSConfig.h</span>. Задание большого массива таким способом может привести к тому, что приложение заберет себе некоторое количество RAM - даже до того, как любой массив будет создан.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Каждая создаваемая задача требует блок управления задачей (<span style=" font-weight:600;">task control block</span>, <span style=" font-weight:600;">TCB</span>) и стек, выделенные из кучи. Рисунок 42 демонстрирует, как heap_1 подразделяет обычный массив кучи в процессе создания задач.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· A показывает массив кучи до создания любой из задач, весь массив свободен.<br />· B показывает массив кучи после того, как была создана одна задача.<br />· C показывает массив кучи после того, как были созданы три задачи.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image800.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 42. RAM, выделяемая в массиве heap при каждом создании задачи</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Heap_2.c</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Модуль Heap_2.c также использует обычный массив в качестве кучи, размером configTOTAL_HEAP_SIZE. Используется улучшенный алгоритм выделения памяти, и в отличие от heap_1 теперь можно освобождать память. Массив кучи также выделяется статически, так что для приложения останется памяти меньше даже до того, как приложение выделит какой-нибудь собственный массив.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Улучшенный алгоритм выделения памяти гарантирует, что pvPortMalloc() использует свободный блок памяти, который ближе всего по размеру к требуемому количеству памяти. Рассмотрим для примера сценарий, где:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1</span>. Куча содержит три блока свободной памяти по 5, 25 и 100 байт соответственно.<br /><span style=" font-weight:600;">2</span>. Функция pvPortMalloc() была вызвана для выделения 20 байт RAM</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Самый маленький подходящий блок свободной памяти RAM 25 байт, поэтому pvPortMalloc() делит 25-байтовый блок на один блок размером 20 байт и один блок размером 5 байт, после чего вернет указатель на 20-байтовый блок. Новый 5-байтовый блок свободной памяти останется доступным для будущего использования при вызовах pvPortMalloc().</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Примечание: это чрезмерное упрощение, потому что heap_2 сохраняет информацию о размерах блоков также в области кучи, так что сумма двух разделенных блоков окажется меньше, чем 25 байт.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Heap_2.c не комбинирует смежные блоки свободной памяти в один блок бОльшего размера, чтобы избавиться от фрагментации - однако фрагментация не будет проблемой, если блоки будут выделены и впоследствии освобождены с тем же размером. Heap_2.c подходит для приложений, которые постоянно создают и удаляют задачи, при этом не изменяя размера стека для создаваемых задач.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image21082.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 43. RAM, выделяемая из массива, когда задача создается и удаляется</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">На рисунке показано, как работает улучшенный алгоритм, когда задача создается, удаляется и создается снова.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· A показывает массив кучи после того, как были созданы три задачи. Самый большой блок свободной памяти остается в верхней части кучи.<br />· B показывает массив кучи после того, как была удалена одна задача. Большой блок свободной памяти остается в верхней части кучи неизменным. Также теперь появляется два свободных блока памяти меньшего размера, в которых раньше размещались стек и TCB удаленной задачи.<br />· C показывает массив кучи после того, как была после этого создана другая задача. Создание задачи происходит в результате двух вызовов pvPortMalloc(), один из которых выделяет память под новый TCB, а другой выделяет память для стека задачи (вызовы pvPortMalloc() происходят внутри API функции xTaskCreate()).</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Каждый TCB имеет точно такой же размер, так что улучшенный алгоритм гарантирует, что блок RAM, который был раннее выделен для TCB удаленной задачи, будет заново использован для TCB новой задачи.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Размер стека, выделенного для новой созданной задачи, идентичен размеру стека ранее удаленной задачи, так что улучшенный алгоритм гарантирует, что блок RAM, который был раннее выделен для стека удаленной задачи, будет заново использован для стека новой задачи.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Большой блок свободной неиспользованной памяти в верхней части кучи остался нетронутым.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Heap_2.c не является детерминированным, однако он является более эффективным чем стандартная реализация библиотечных malloc() и free().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Heap_3.c</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Модуль Heap_3.c просто использует стандартные библиотечные функции malloc() и free(), однако делает вызовы этих функций защищенными для использования с потоками путем приостановки работы шедулера. Само собой, никакого детерминизма тут и близко нет. Heap_3.c подходит для общего случая задач, использующих сложную логику создания и удаления задач в процессе работы, и не особо критичных к точности времени выполнения. Реализация показана в листинге 74.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Размер кучи FreeRTOS не зависит от configTOTAL_HEAP_SIZE и вместо этого задается в конфигурации линкера.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvPortMalloc( size_t xWantedSize )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvReturn;<br />  vTaskSuspendAll();<br />  {<br />     pvReturn = malloc( xWantedSize );<br />  }<br />  xTaskResumeAll();<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">return</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> pvReturn;<br />}<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vPortFree( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pv )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( pv != NULL )<br />  {<br />     vTaskSuspendAll();<br />     {<br />         free( pv );<br />     }<br />     xTaskResumeAll();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></html>