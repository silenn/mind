<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'Georgia'; font-size:11pt; font-weight:400; font-style:normal;">
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td width="100%">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">FreeRTOS: практическое применение, часть 2 (управление очередями) </span></p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· Как создавать очередь.<br />· Как очередь управляет данными, которые в ней содержатся.<br />· Как данные посылаются (помещаются) в очередь.<br />· Как данные принимают (получают) из очереди.<br />· Что такое блокировка на очереди.<br />· Какой эффект оказывают приоритеты задачи при записи в очередь и чтении из очереди.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2.2. Характеристики очереди</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Хранилище данных (Data Storage)</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Очередь может хранить в себе конечное количество элементов данных фиксированного размера. Максимальное количество элементов, которое может хранить очередь, называют длиной (<span style=" font-weight:600;">length</span>) очереди. При создании очереди указывают совместно длину очереди и размер каждого элемента данных.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обычно очереди работают как буфер по принципу 'первый вошел - первый вышел' (<span style=" font-weight:600;">FIFO</span>, First In First Out), где данные записываются в конец (в хвост) очереди, а считываются и удаляются из начала (из головы) очереди. Также можно записывать данные и в начало очереди.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Запись в буфер вызывает побайтовое копирование данных, которые должны быть сохранены в самой очереди. Чтение данных из очереди вызывает также копирование данных из очереди, при этом данные из очереди удаляются. На рисунке 19 показана запись данных в очередь и чтение данных из очереди, и эффект сохранения данных в очереди для каждой операции.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image26833.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image6602.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image19988.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image31520.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image4002.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 19. Пример последовательности записи в очередь и чтения из очереди</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Доступ к очереди для нескольких задач</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Очереди являются объектами со своими собственными правами, которыми не владеют любые отдельные задачи, и эти права не могут быть установлены никакими задачами. Любое количество задач может записывать данные в одну и ту же очередь, и любое количество задач может читать данные из одной и той же очереди. Ситуация, когда в одну очередь пишут данные несколько задач вполне обычна. Однако очень редко бывает, что из одной очереди читают данные несколько задач.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Блокировка на чтение очереди</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда задача делает попытку чтения из очереди, она (задача) может указать опционально время блокировки. Это время, в течение которого задача должна находиться в состоянии <span style=" font-weight:600;">Blocked</span> при ожидании появления данных в очереди, если пока очередь пуста. Задача, ожидающая появления данных в очереди, немедленно переходит из состояния Blocked в состояние <span style=" font-weight:600;">Ready</span>, когда другая задача или прерывание помещает данные в очередь. Также задача автоматически переходит из состояния Blocked в состояние Ready, если истекло время блокировки, а данные в очереди к этому моменту так и не появились.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Очереди могут иметь несколько читающих задач, так что возможна ситуация, когда на одной очереди имеется более одной задачи, ожидающей появления данных в режиме Blocked. В этом случае только одна задача будет разблокирована, когда данные наконец поступят. Эта разблокированная задача будет иметь наивысший приоритет из всех задач, ожидающих данные. Если блокированные (ожидающие данные) задачи имеют одинаковый приоритет, то будет разблокирована задача, которая дольше всех ждет данные.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Блокировка на записи очереди</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Точно так же, как и при чтении из очереди, задача может указать (что также необязательно) время блокировки для записи в очередь. В этом случае это время блокировки соответствует максимальному времени, в котором задача должна удерживаться в состоянии Blocked при ожидании появления свободного места в очереди, если очередь уже полностью заполнена.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">У очередей может быть несколько записывающих в них задач, с возможной блокировкой более чем одной задачи на ожидании завершения операции записи. В этом случае только одна задача будет разблокирована, когда появится свободное место в очереди. Задача, которая при этом разблокируется, будет иметь самый высокий приоритет среди всех задач, ожидающих появления свободного места. Если заблокированные задачи имеют равный приоритет, то разблокируется та задача, которая дольше всех задач ждет разблокировки.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2.3. Использование очереди</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">xQueueCreate()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Очередь перед использованием должна быть явно создана.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обращение к очереди происходит через переменную типа xQueueHandle. Функция xQueueCreate() используется для создания очереди и возвращает xQueueHandle в качестве ссылки на созданную очередь.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Для создания очереди FreeRTOS выделяет память RAM из кучи (heap). RAM используется как для структур данных очереди, так и для элементов, которые будут помещены в очередь или считаны из неё. В случае нехватки памяти в heap RAM функция xQueueCreate() при попытке создания очереди вернет NULL. Часть 5 более подробно рассматривает управление памятью heap.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прототип API функции xQueueCreate():</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:40px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength,<br />                           unsigned portBASE_TYPE uxItemSize);</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Параметры и значение возврата функции xQueueCreate():</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#3366ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра</span><br /><span style=" font-weight:600; color:#ffffff;">/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#3366ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание<br /></span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">uxQueueLength</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Максимальное количество элементов, которое можно сохранить в очереди в любой момент времени.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">uxItemSize</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Размер в байтах каждого элемента данных, который можно сохранить в очереди.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Если функция вернула не NULL, то значит очередь создана успешно. Возвращенная величина в этом случае должна быть сохранена как хендл к созданной очереди.</span></p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функции <span style=" font-weight:600;">xQueueSendToBack()</span> и <span style=" font-weight:600;">xQueueSendToFront()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-weight:600;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Как и можно ожидать, xQueueSendToBack() используется для отправки данных в конец (хвост) очереди, а xQueueSendToFront() используется для отправки данных в начало (голову) очереди.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция xQueueSend() эквивалентна и полностью та же самая, что и xQueueSendToBack().</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Никогда не делайте вызов xQueueSendToFront() или xQueueSendToBack() из процедуры обработчика прерывания (ISR, Interrupt Service Routine). Вместо этого должны использоваться защищенные версии xQueueSendToFrontFromISR() и xQueueSendToBackFromISR().</span> Они описаны в части 3.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прототип API функции xQueueSendToFront():</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:40px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">portBASE_TYPE xQueueSendToFront( xQueueHandle xQueue,<br />                                 </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * pvItemToQueue,<br />                                 portTickType xTicksToWait );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прототип API функции xQueueSendToBack():</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:40px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">portBASE_TYPE xQueueSendToBack( xQueueHandle xQueue,<br />                                </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * pvItemToQueue,<br />                                portTickType xTicksToWait );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Параметры и значение возврата функций xQueueSendToFront() и xQueueSendToBack().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#3366ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра<br />/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#3366ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание<br /></span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xQueue</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Хендл очереди, в которую данные посылаются (записываются). Хендл очереди берут из значения, которое вернула функция xQueueCreate() при создании очереди.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">pvItemToQueue</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Указатель на данные, которые копируются в очередь.</span><br /><br />Размер каждого элемента очереди, который она может хранить, устанавливается при создании очереди, таким образом это количество байт будет скопировано из памяти по указателю pvItemToQueue в область хранения данных, принадлежащую очереди.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xTicksToWait</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Максимальное количество времени, в течение которого задача должна оставаться в состоянии Blocked в ожидании, пока не появится в очереди свободное место для записи (если очередь уже заполнена).</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обе функции и xQueueSendToFront(), и xQueueSendToBack() сделают возврат немедленно, если xTicksToWait указан 0 и если очередь уже заполнена.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Время блокировки указывается в периодах тика, поэтому абсолютное время ожидания зависит от частоты следования тиков. Для преобразования времени в миллисекундах во время в тиках может использоваться константа portTICK_RATE_MS.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Установка xTicksToWait в значение portMAX_DELAY приведет к тому, что задача будет ждать бесконечно (таймаута разблокировки не будет), что обеспечивается установкой в 1 значения INCLUDE_vTaskSuspend в файле FreeRTOSConfig.h.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Возможны две величины возврата:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">1. pdPASS - вернется только тогда, когда данные успешно отправлены в очередь.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если указано время блокировки (xTicksToWait было не равным 0), то возможно что вызвавшая функцию задача помещается в состояние Blocked для ожидания появления свободного места в очереди. В этом случае значение pdPASS будет возвращено, если в очереди появилось свободное место до истечения времени блокировки.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">2. errQUEUE_FULL - будет возвращено, если данные не были записаны в очередь, так как очередь уже полностью заполнена.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если указано время блокировки (xTicksToWait было не равным 0), то вызвавшая функцию задача была помещена в состояние Blocked для ожидания, пока другая задача или обработчик прерывания освободят место в очереди, но указанное время блокировки истекло, а свободное место в очереди так и не появилось.</p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функции <span style=" font-weight:600;">xQueueReceive()</span> и <span style=" font-weight:600;">xQueuePeek()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-weight:600;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция xQueueReceive() используется для приема (чтения) элемента из очереди. При этом принятый элемент удаляется из очереди.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция xQueuePeek() используется для приема элемента из очереди без удаления элемента из очереди. Функция xQueuePeek() читает элемент из головы очереди без модификации данных, которые сохранены в очереди или, другими словами, без модификации порядка сохраненных данных в очереди (состояние очереди остается неизменным).</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Никогда не делайте вызов xQueueReceive() или xQueuePeek() из процедуры обработчика прерывания (ISR, Interrupt Service Routine). Защищенная версия xQueueReceiveFromISR() описана в части 3.</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прототипы API функций xQueueReceive() и xQueuePeek():</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:40px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">portBASE_TYPE xQueueReceive( xQueueHandle xQueue,<br />                             </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * pvBuffer,<br />                             portTickType xTicksToWait );<br /><br />portBASE_TYPE xQueuePeek   ( xQueueHandle xQueue,<br />                             </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * pvBuffer,<br />                             portTickType xTicksToWait ); </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Параметры и значение возврата функций xQueueReceive() и xQueuePeek():</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#3366ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра<br />/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#3366ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание<br /></span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xQueue</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Хендл очереди, из которой данные принимаются (читаются). Хендл очереди берут из значения, которое вернула функция xQueueCreate() при создании очереди.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">pvBuffer</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Указатель на память, куда будут копироваться принятые из очереди данные.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Размер каждого элемента данных (в байтах), которые хранит очередь, устанавливается при создании очереди. Память, на которую указывает pvBuffer, должна быть в байтах объемом не меньше размера одного элемента данных.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xTicksToWait</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Максимальное количество времени, в течение которого задача должна оставаться в состоянии Blocked в ожидании, пока не появится в очереди доступный для чтения элемент данных (если очередь уже пуста).</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обе функции и xQueueReceive(), и xQueuePeek() сделают возврат немедленно, если xTicksToWait указан 0 и если очередь уже пуста.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Время блокировки указывается в периодах тика, поэтому абсолютное время ожидания зависит от частоты следования тиков. Для преобразования времени в миллисекундах во время в тиках может использоваться константа portTICK_RATE_MS.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Установка xTicksToWait в значение portMAX_DELAY приведет к тому, что задача будет ждать бесконечно (таймаута разблокировки не будет), что обеспечивается установкой в 1 значения INCLUDE_vTaskSuspend в файле FreeRTOSConfig.h.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Возможны две величины возврата:</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">1. pdPASS - вернется только тогда, когда данные успешно прочитаны из очереди.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если указано время блокировки (xTicksToWait было не равным 0), то возможно что вызвавшая функцию задача помещается в состояние Blocked для ожидания появления доступного элемента данных в очереди. В этом случае значение pdPASS будет возвращено, если в очереди появился элемент до истечения времени блокировки.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">2. errQUEUE_EMPTY - будет возвращено, если данные не были прочитаны из очереди, так как очередь уже пуста.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если указано время блокировки (xTicksToWait было не равным 0), то вызвавшая функцию задача была помещена в состояние Blocked для ожидания, пока другая задача или обработчик прерывания не запишут что-нибудь в очередь, но указанное время блокировки истекло, а доступный для чтения элемент в очереди так и не появился.</p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">uxQueueMessagesWaiting()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция uxQueueMessagesWaiting() используется для опроса очереди на количество содержащихся в ней сейчас элементов.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Никогда не вызывайте uxQueueMessagesWaiting() из процедуры обработчика прерывания (ISR, Interrupt Service Routine). Вместо этого должна использоваться защищенная версия uxQueueMessagesWaitingFromISR().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прототип API функции uxQueueMessagesWaiting():</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:40px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">unsigned portBASE_TYPE uxQueueMessagesWaiting( xQueueHandle xQueue );</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Параметры и значение возврата функции uxQueueMessagesWaiting():</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#3366ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра<br />/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#3366ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание<br /></span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xQueue</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Хендл очереди, которая опрашивается. Хендл очереди берут из значения, которое вернула функция xQueueCreate() при создании очереди.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Количество элементов, которые сейчас находятся на хранении в очереди. Если функция вернула 0, то очередь пуста.</span></p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Пример 10. Блокировка на приеме из очереди</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот пример демонстрирует создание очереди, отправку данных в очередь из нескольких задач и прием данных из очереди одной задачей. Очередь создается для размещения в себе данных типа long. Задачи, которые отправляют данные в очередь, не указывают при этом время блокировки, а задача, которая принимает данные из очереди, указывает время блокировки.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Приоритет задач, отправляющих данные в очередь, меньше, чем приоритет задачи, которая эти данные из очереди принимает. Это означает, что очередь никогда не будет содержать в себе более одного элемента данных, потому что как только данные будут отправлены в очередь, то сразу будет разблокирована принимающая данные задача, вытеснит задачу, поместившую данные в очередь, и удалит данные из очереди - очередь снова сразу станет пустой.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 34 показывает реализацию задачи, которая записывает в очередь. Будут созданы два экземпляра этой задачи, один из которых будет постоянно записывать в очередь значение 100, а другой будет постоянно записывать в ту же самую очередь значение 200. Параметр задачи используется для того, чтобы передать каждому экземпляру задачи эти значения.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 34. Реализация передающей задачи, используемой в примере 10</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vSenderTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lValueToSend;<br />portBASE_TYPE xStatus; <br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Будут созданы два экземпляра этой задачи, а величина, посылаемая</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     в очередь, будет передана в задачу через параметр задачи - благодаря</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     этому каждый экземпляр задачи будет использовать свое значение.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     Очередь была создана для сохранения в себе значений с типом long, и</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     здесь делается приведение типа данных к требуемому. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  lValueToSend = ( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> ) pvParameters;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Как и большинство других задач, эта задача реализована как<br />     бесконечный цикл. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Отправка значения в очередь.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Первый параметр определяет очередь, в которую отправляются данные.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Очередь была создана до запуска шедулера, поэтому создание очереди</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        было до начала выполнения этой задачи.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Второй параметр - адрес посылаемых данных, в нашем случае это будет</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        адрес локальной переменной lValueToSend.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Третий параметр время блокировки – время, в котором задача должна</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        удерживаться в состоянии Blocked для ожидания появления свободного</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        места в очереди, если очередь уже полностью заполнена. В этом случае</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        время блокировки не указано, потому что по выбранному алгоритму работы</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        приложения очередь никода не будет содержать больше одного элемента</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        данных, и поэтому никогда не переполнится. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xStatus = xQueueSendToBack( xQueue, &amp;lValueToSend, 0 );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xStatus != pdPASS )<br />     {<br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Операция отправки не завершена, потому что очередь была заполнена -</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">            это должно означать ошибку, так как в нашем случае очередь никогда</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">            не будет содержать больше одного элемента данных! */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />         vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Could not send to the queue.\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />     }<br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Разрешение выполняться для других задач, отправляющих данные<br />        в очередь.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Вызов taskYIELD() информирует шедулер, что сейчас сразу</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        нужно переключиться к другой задаче, а не поддерживать эту задачу в</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        состоянии Running до окончания текущего слайса времени. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     taskYIELD();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В листинге 35 показана реализация задачи, которая принимает данные из очереди. Принимающая задача указывает время блокировки 100 миллисекунд, на которые она войдет в состояние Blocked, пока либо данные не появятся в очереди, либо не истекут 100 миллисекунд таймаута без появления данных. В нашем примере таймаут 100 миллисекунд никогда не произойдет, так как две задачи постоянно записывают данные в очередь.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 35. Реализация принимающей задачи, используемой в примере 10:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vReceiverTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Декларирование переменной, которая будет хранить значения, принятые<br />   из очереди. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lReceivedValue;<br />portBASE_TYPE xStatus;<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> portTickType xTicksToWait = 100 / portTICK_RATE_MS;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Эта задача также определена как бесконечный цикл. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Этот опрос очереди всегда должен определять, что очередь пуста, потому<br />        что эта задача будет немедленно удалять данные из очереди, которые туда<br />        были только что записаны. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( uxQueueMessagesWaiting( xQueue ) != 0 )<br />     {<br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">//Печать &quot;Очередь должна была быть пустой!&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />         vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Queue should have been empty!\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />     }<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Прием данных из очереди.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Первый параметр определяет очередь, из которой данные будут прочитаны.<br />        Очередь была создана перед запуском шедулера, и поэтому перед тем,<br />        как эта задача запустится в первый раз.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Второй параметр - адрес буфера, в который принятые данные будут<br />        помещены. В нашем случае здесь просто указан адрес переменной,<br />        которая имеет нужный размер, чтобы удержать в себе принятые данные.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Последний параметр время блокировки – максимальное время, в котором<br />        задача должна оставаться в состоянии Blocked, ожидая появления<br />        данных на очереди. Здесь используется константа portTICK_RATE_MS<br />        для преобразования 100 миллисекунд во время, указанное в тиках. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xStatus = xQueueReceive( xQueue, &amp;lReceivedValue, xTicksToWait ); <br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xStatus == pdPASS )<br />     {<br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Данные успешно приняты из очереди, печать принятого значения. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />         vPrintStringAndNumber( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Received = &quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, lReceivedValue );<br />     }<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">else</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     {<br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Данные не были приняты из очереди даже после ожидания 100 мс.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">            Это должно означать ошибку, так как отправляющие данные в очередь<br />            задачи работают постоянно записывают данные в очередь. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />         vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Could not receive from the queue.\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />     }<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 36 содержит код для функции main(). Она просто создает очередь и три задачи перед запуском шедулера. Очередь создается для удержания в себе максимум 5 значений чисел типа long, с запасом - даже с учетом того, что приоритеты задач настроены так, что очередь никогда не будет содержать в себе больше одного элемента в любой момент времени.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 36. Реализация функции main() примера 10:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Декларирование переменной типа xQueueHandle. Она используется для сохранения<br />   ссылки на очередь, к которой будут обращаться все три задачи. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />xQueueHandle xQueue;<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> main( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Очередь создается для удержания в себе до 5 элементов включительно, каждый</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     из элементов настолько велик, что его размер достаточен для хранения типа<br />     long. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xQueue = xQueueCreate( 5, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">sizeof</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> ) );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xQueue != NULL )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание двух экземпляров задач, которые будут отправлять данные<br />        в очередь. Параметр задачи используется для передачи значения,<br />        которое будет писаться</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">задачей в очередь, так что одна задача<br />        будет постоянно записывать в очередь</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">число 100, а другая задача<br />        будет постоянно записывать число 200. Обе задачи</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">создаются<br />        с одинаковым приоритетом 1. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( vSenderTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Sender1&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, ( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * ) 100, 1, NULL );<br />     xTaskCreate( vSenderTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Sender2&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, ( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * ) 200, 1, NULL );<br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание задачи, которая будет читать из очереди. Задача создается<br />        с приоритетом 2, что выше приоритета задач, помещающих данные<br />        в очередь. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( vReceiverTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Receiver&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, NULL, 2, NULL );<br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Запуск шедулера, после чего созданные задачи начнут выполняться. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskStartScheduler();<br />  }<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">else</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Очередь не может быть создана. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  }<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Если все хорошо, то управление в main() никогда не дойдет до этой точки,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     и теперь шедулер будет управлять задачами. Если main() довела управление<br />     до</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">этого места, то это может означать, что не хватает памяти кучи (heap)</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     для создания специальной задачи ожидания (idle task, об этой задаче<br />     далее). Часть 5 предоставляет больше информации по управлению памятью. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; );<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задачи, которые отправляют данные в очередь, делают вызовы taskYIELD() при каждой итерации в своем бесконечном цикле. Функция taskYIELD() информирует шедулер, что сейчас немедленно нужно переключиться на другую задачу и не оставлять текущую задачу в состоянии Running до окончания текущего слайса времени. Задача, которая вызвала taskYIELD(), предлагает сразу удалить себя из состояния Running. Обе задачи, которые отправляют данные в очередь, имеют одинаковый приоритет, и каждый раз при вызове taskYIELD() переходят из состояния Running в состояние Ready, давая другой отправляющей задаче (которая уже в состоянии Ready, и ждет в этом состоянии дольше) возможность войти в состояние Running. Поэтому две задачи передают данные поочередно - то одна, то другая. Вывод, производимый примером 10, показан ниже.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image28300.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 21. Вывод, который производит при выполнении пример 10.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рисунок 22 показывает последовательность выполнения задач.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image6857.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 22. Последовательность выполнения примера 10.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Использование очередей для передачи составных типов данных</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обычным случаем является прием в одной задаче (приемник) данных от нескольких других задач (передатчиков) через одну и ту же очередь. Часто приемнику данных нужно знать, откуда пришли данные, чтобы он мог определить, как их следует обработать. Простейший способ достичь этого - использовать очередь для передачи структур, где будут сохранены как сами данные, так и информация об источнике данных, содержащаяся в одном из полей структуры. Эта схема демонстрируется на рисунке 23.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image24085.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 23. Пример сценария, в котором через очередь передаются структуры.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Описание процесса на рисунке 23:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· Создается очередь для удержание в себе структур типа xData. Поля структуры содержат значение данных (iValue), и код (iMeaning), показывающий, что означают данные, которые отправляются на очередь в одном сообщении.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· Центральная задача Контроллер используется для реализации главного функционала системы. Он заключается в реагировании на входы и изменении состояния системы в соответствии с информацией, переданной через очередь.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· Задача шины CAN используется для инкапсулирования в себе функционала интерфейса шины CAN. Когда задача шины CAN принимает и декодирует сообщение, она посылает это сообщение задаче Контроллер в декодированной форме, как данные структуры xData. Поле iMeaning передаваемой через очередь структуры используется для указания задаче Контроллер о том, что из себя представляют данные - в рассмотренном примере это скорость мотора. Поле iValue передаваемой структуры используется задачей Контроллер как данные о необходимой скорости мотора.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· Задача HMI (Human Machine Interface, интерфейс человек-машина) используется для инкапсуляции в себе функционала общения с человеком. Оператор машины может вводить команды и запрашивать значения разными способами, что детектируется и интерпретируется задачей HMI. Когда поступает новая команда на вход задачи HMI, то она посылает её задаче Контроллер в структуре xData. Как обычно, в поле iMeaning передаваемой структуры закодирован смысл команды, чтобы задача Контроллер могла знать, что из себя представляют данные - в рассмотренном примере это установка нового положения точки позиционирования. В поле iValue передаваемой структуры закодировано значение установки точки.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Пример 11. Блокировка при отправке в очередь / отправка структур через очередь</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Пример 11 очень похож на пример 10, но приоритеты задачи изменены, так что принимающая задача имеет приоритет, меньший чем приоритет отправляющих задач. Кроме того, теперь очередь используется для передачи структур между задачами, а не простых целых чисел типа long.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 37. Определение структуры, которая передается через очередь, плюс декларация двух переменных для использования в примере.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Определение типа для структуры, которая будет передаваться через очередь. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />typedef </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">struct</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />{<br />  unsigned </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> ucValue;<br />  unsigned </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> ucSource;<br />} xData;<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Определение двух переменных, имеющих тип xData. Эти переменные <br />   будут передаваться через очередь. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> xData xStructsToSend[ 2 ] =<br />{<br />  { 100, mainSENDER_1 }, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Используется Sender1 (передатчик 1). */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  { 200, mainSENDER_2 }  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Используется Sender2 (передатчик 2). */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />};</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В примере 10 принимающая задача имеет самый высший приоритет, поэтому в очереди не может никогда содержаться больше одного элемента. Так происходит потому, что принимающая задача (приемник) сразу вытесняет отправляющие задачи (передатчик 1 и 2), как только они поместят данные в очередь. В примере 11 отправляющие задачи имеют наивысший приоритет, поэтому очередь обычно всегда переполнена. Понятно почему - принимающая данные задача всегда вытесняется передатчиками, как только в буфере появилось хотя бы одно свободное место, и буфер сразу снова заполняется. При этом отправляющие задачи снова входят в режим Blocked и снова ждут появления свободного места в очереди.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В листинге 38 показана реализация передающей задачи. Передающая задача указывает время своей блокировки 100 миллисекунд, на которые она входит в режим блокировки для ожидания появления места в буфере - когда очередь становится заполненной. Она покидает состояние блокировки (Blocked), когда либо появится свободное место в очереди, либо когда пройдет время 100 миллисекунд. В этом примере таймаут 100 мс никогда не истекает, так как принимающая задача постоянно освобождает место, удаляя элементы данных из очереди.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vSenderTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br />portBASE_TYPE xStatus;<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> portTickType xTicksToWait = 100 / portTICK_RATE_MS;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Как и большинство других задач, эта задача реализована как бесконечный<br />     цикл. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Отправка в очередь.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Второй параметр - адрес отправляемой структуры. Адрес передается</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        как параметр задачи, для чего напрямую используется pvParameters.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Третий параметр время блокировки - время, которое задача должна быть</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        в состоянии Blocked, ожидая появления доступного места на очереди,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        если очередь уже полна. Время блокировки указано потому, что</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        отправляющие задачи имеют более высокий приоритет, чем принимающая</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        задача, так что ожидается, что очередь сразу заполнится. Принимающая</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        задача будет запускаться и удалять элементы данных из очереди, когда</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        обе отправляющие задачи находятся в состоянии Blocked. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xStatus = xQueueSendToBack( xQueue, pvParameters, xTicksToWait );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xStatus != pdPASS )<br />     {<br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Операция отправки не завершена, даже после истечения 100 мс.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">            Это должно означать ошибку, так как принимающая задача должна</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">            освобождать место в очереди, как только обе отправляющие задачи</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">            войдут в состояние Blocked. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />         vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Could not send to the queue.\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />     }<br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Разрешаем выполниться другой такой же задаче, отправляющей данные<br />        в очередь. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     taskYIELD();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Принимающая задача имеет самый низкий приоритет, поэтому она запускается только тогда, когда обе отправляющие задачи находятся в состоянии Blocked. Отправляющие задачи будут в этом состоянии Blocked только тогда, когда очередь заполнится, так что принимающая задача запустится, когда очередь уже полна. Таким образом подразумевается, что принимаемые данные для принимающей задачи есть всегда, так что нет необходимости указания времени блокировки принимающей задачи.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 39. Реализация принимающей задачи для примера 11</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vReceiverTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Декларирование переменной - структуры, которая будет хранить значения,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   принятые из очереди. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />xData xReceivedStructure;<br />portBASE_TYPE xStatus;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Эта задача также определена как бесконечный цикл. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Так как эта задача имеет самый низкий приоритет, она работает только</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        когда отправляющие задачи находятся в состоянии Blocked. Отправляющие<br />        задачи войдут в состояние Blocked, когда очередь станет заполненной,<br />        так что эта задача всегда подразумевает, что в очереди есть элементы<br />        данных, количество которых равно длине очереди. Для нашего примера<br />        это количество равно 3. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( uxQueueMessagesWaiting( xQueue ) != 3 )<br />     {<br />         vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Queue should have been full!\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />     }<br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Прием из очереди.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Второй параметр - буфер, в который будут помещены принятые из очереди</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        данные. В нашем случае буфер - это просто адрес переменной, которая<br />        имеет требуемый размер для удержания данных принятой структуры.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Последний параметр - лимит времени, в котором задача остается<br />        в состоянии Blocked при ожидании появления данных в очереди,<br />        если она пуста. Для нашего случая время блокировки не требуется,<br />        потому что эта задача будет запущена только тогда, когда очередь<br />        вся заполнена данными. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xStatus = xQueueReceive( xQueue, &amp;xReceivedStructure, 0 );<br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xStatus == pdPASS )<br />     {<br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Данные были успешно приняты из очереди, вывод принятого значения</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">            и источника этого значения. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xReceivedStructure.ucSource == mainSENDER_1 )<br />         {<br />            vPrintStringAndNumber( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;From Sender 1 = &quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, xReceivedStructure.ucValue );<br />         }<br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">else</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />         {<br />            vPrintStringAndNumber( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;From Sender 2 = &quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, xReceivedStructure.ucValue );<br />         }<br />     }<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">else</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     {<br />         </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Из очереди ничего не принято. Это должно означать ошибку, так как<br />            эта задача может быть запущена только при заполненной очереди. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />         vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Could not receive from the queue.\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );<br />     }<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция main() примера 11 (по сравнению с предыдущим примером 10) почти не изменилась. Очередь создается для удержания трех структур xData, порядок приоритетов и изменен на обратный. Реализация main() показана в листинге 40.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> main( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Очередь создается для удержания в себе максимум 3 элементов типа xData. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xQueue = xQueueCreate( 3, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">sizeof</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xData ) );<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xQueue != NULL )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание двух экземпляров задач, которые будут отправлять данные<br />        в очередь. Параметр задачи используется для передачи структуры,<br />        которая будет писаться</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">задачей в очередь, так что одна задача<br />        будет постоянно записывать в очередь xStructsToSend[0], а другая<br />        задача будет постоянно записывать xStructsToSend[1].</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        Обе задачи создаются с одинаковым приоритетом 2 (приоритет 2 выше,<br />        чем у</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">задачи-приемника). */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( vSenderTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Sender1&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, &amp;( xStructsToSend[ 0 ] ), 2, NULL );<br />     xTaskCreate( vSenderTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Sender2&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, &amp;( xStructsToSend[ 1 ] ), 2, NULL );<br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание задачи, которая будет читать из очереди. Задача создается<br />        с приоритетом 1, что ниже приоритета задач, помещающих данные<br />        в очередь. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( vReceiverTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Receiver&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, NULL, 1, NULL );<br /><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Запуск шедулера, после чего созданные задачи начнут выполняться. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskStartScheduler();<br />  }<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">else</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Очередь не может быть создана. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  }<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Если все хорошо, то управление в main() никогда не дойдет до этой точки,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     и теперь шедулер будет управлять задачами. Если main() довела управление<br />     до</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">этого места, то это может означать, что не хватает памяти кучи (heap)</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     для создания специальной задачи ожидания (idle task, об этой задаче<br />     далее).</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Часть 5 предоставляет больше информации по управлению памятью. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; );<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В примере 11 точно так же, как и в примере 10, передающие задачи в бесконечном цикле, на каждой своей итерации отправляют данные в очередь и уступают возможность сделать тоже самое для другой задачи. Вывод, производимый примером 11, показан на рисунке 24.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image30621.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рисунок 25 демонстрирует последовательность выполнения, являющейся результатом того, что отправляющие задачи имеют приоритет выше, чем принимающая задача. Более подробно рисунок 25 описан в таблице 11.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image7072.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 25. Последовательность выполнения примера 11</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Таблица 11. Описание ключевых точек времени рисунка 25.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Время<br /></span></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание<br /></span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t1</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Задача передатчик 1 выполняется и отправляет данные на очередь.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t2</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Задача передатчик 1 уступает (вызовом taskYIELD()) выполнение задаче передатчик 2.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t3</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Теперь передатчик 2 уступает передатчику 1. Передатчик 1 записывает данные в очередь, и заполняет её полностью.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t4</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Передатчик 1 уступает выполнение Передатчику 2.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t5</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Передатчик 2 делает попытку записи в очередь. Поскольку очередь была полностью заполнена, то передатчик 2 входит в режим Blocked, ожидая появления свободного места в очереди, чем позволяет снова запуститься задаче передатчика 1.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t6</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Передатчик 1 также делает попытку записи в очередь. Поскольку очередь уже заполнена, передатчик также входит в состояние Blocked для ожидания появления свободного места в очереди. Теперь обе задачи передатчиков - и 1, и 2 - находятся в состоянии Blocked, благодаря чему задача приемника с более низким приоритетом имеет возможность запуститься.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t7</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Задача приемника удаляет один элемент xData из очереди. Как только в очереди появилось свободное место, передатчик 2 покидает состояние Blocked и, как задача с более высоким приоритетом, вытесняет задачу Приемник. Передатчик 2 пишет в очередь, чем снова заполняет свободное место в очереди, освобожденное приемником. Теперь очередь снова заполнена. Передатчик 2 делает вызов taskYIELD(), но передатчик 1 не выходит из состояния Blocked, поэтому передатчик 2 заново выбирается как задача с состоянием Running и продолжает выполнение после вызова taskYIELD().</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t8</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Возникает новая итерация цикла передатчика 2, и он снова делает попытку записи в очередь, и снова попадает в состояние Blocked, так как очередь заполнена. Снова начинает выполнение задача приемника, так как оба передатчика в состоянии Blocked.</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">t9</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Задача приемника удалила снова один элемент из очереди. Так как в очереди появилось свободное место, то передатчик 1 выходит из состояния Blocked (выходит именно передатчик 1, а не передатчик 2, так как передатчик 1 дольше всего ждет в состоянии Blocked, а приоритеты у передатчиков 1 и 2 одинаковые) и, как задача с самым высоким приоритетом, вытесняет задачу приемника. Передатчик 1 записывает в очередь, снова заполняет пустое место, созданное задачей приемника. Очередь снова полностью заполнена. Передатчик 1 делает вызов taskYIELD(), но передатчик 2 не выходит из состояния Blocked, поэтому передатчик 1 заново выбирается как задача с состоянием Running и продолжает выполнение после вызова taskYIELD(). Возникает новая итерация цикла передатчика 1, и он снова делает попытку записи в очередь, и снова попадает в состояние Blocked, так как очередь заполнена.</span></p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Снова начинается выполнение задача приемника, так как оба передатчика в состоянии Blocked, и далее цикл продолжается.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2.4. Работа с большими объемами данных</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если сохраняемый в очереди размер данных велик, то выгоднее использовать очередь для передачи указателей на данные, в отличие от копий самих данных, так как иначе при побайтной пересылке данных в очередь и вычитывании данных из очереди повышаются накладные расходы ресурсов. Передача указателей более эффективна по затратам процессорного времени и требуемого RAM для создания очереди. Однако при применении указателей в очереди очень важно иметь в виду следующее:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1</span>. Должен быть ясно определен владелец RAM, на которую настроены указатели.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда память используется совместно несколькими задачами, необходимо убедиться, что обе задачи не модифицируют содержимое памяти одновременно, или не предпринимают другие действия, которые могут привести к недостоверному содержимому памяти. Идеальный вариант - только передающей задаче разрешен доступ к памяти в процессе постановки в очередь указателя, и только принимающей задаче должен быть разрешен доступ к памяти после того как указатель был получен из очереди.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2</span>. Указываемая указателями память RAM должна сохранять верное содержание.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если память, на которую настроены указатели, была выделена динамически (malloc), то только одна задача должна отвечать за освобождение этой памяти. Ни одна из задач не должна делать попыток обращения к памяти после её освобождения.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Указатели никогда не должны использоваться для доступа к данным, размещенным в стеке задачи. Данные станут неправильными, как только окно стека будет изменено.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></html>