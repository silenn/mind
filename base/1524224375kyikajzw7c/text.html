<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'Georgia'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">6.1. Введение</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Эта часть рассматривает общие проблемы, с которыми сталкиваются пользователи, которые только начали осваивать FreeRTOS.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Наиболее подробно рассматриваются проблемы переполнения стека и детектирования переполнения стека, потому что практика показала, что проблемы стека наиболее часто встречаются в запросах поддержки у пользователей из года в год. Также кратко, в стиле FAQ будут затрагиваются другие распространенные ошибки, их возможные причины и методы решения.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">printf-stdarg.c</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">При использовании стандартных библиотечных функций C стек может использоваться очень интенсивно, особенно при вводе/выводе и поддержке строковых функций, таких как <span style=" font-weight:600;">sprintf()</span>. Загружаемый пакет <span style=" font-weight:600;">FreeRTOS</span> включает файл, который называется printf-stdarg.c - он содержит эффективную версию sprintf(), которая по минимуму использует стек, и может заменить во многих случаях стандартную библиотечную версию sprintf(). Часто это позволит выделить меньше памяти под стек для каждой задачи, которая вызывает sprintf() и похожие функции.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Модуль printf-stdarg.c имеет открытый исходный код (open source), однако права на его использование принадлежат другому производителю, так что этот модуль лицензируется отдельно от FreeRTOS. Условия лицензии содержатся в начале файла исходного кода модуля.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">6.2. Переполнение стека</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">FreeRTOS предоставляет несколько возможностей для облегчения диагностики и отладки проблем, связанных со стеком.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Примечание: к сожалению, эти возможности не могут быть использованы в симулируемой среде DOS, потому что DOS использует сегментированную память. Поэтому невозможно предоставить пример, демонстрирующий их использование в среде Open Watcom.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">uxTaskGetStackHighWaterMark()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Каждая задача содержит собственный стек, общий размер которого указывается при создании задачи. Функция uxTaskGetStackHighWaterMark() используется для запроса величины, насколько было переполнено пространство памяти, выделенное под стек. Эта величина называется '<span style=" font-weight:600;">high water mark</span>' (верхняя ватерлиния, сокращенно <span style=" font-weight:600;">HWM</span>).</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прототип API функции uxTaskGetStackHighWaterMark():</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Таблица 20. Параметры и значение возврата функции uxTaskGetStackHighWaterMark() </p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Имя параметра<br />/<br />возвращаемое значение<br /></span></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание<br /></span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">xTask</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хендл задачи (субъект задачи), у которой запрашивается HWM - см. параметр pxCreatedTask API функции xTaskCreate() для информации по получению хендлов задач.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача может запросить HWM собственного стека, передав NULL вместо действительного значения хендла.</p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Эта величина становится больше и меньше в зависимости от выполнения задачи и обработки прерываний. Функция uxTaskGetStackHighWaterMark() вернет минимальное значение оставшегося места в стеке, которое было доступно после того, как задача начала выполнение. Эта величина остается неиспользованной, когда использование стека было самым большим. Возвращаемое значение, приближающееся к 0 означает, что имеется угроза переполнения стека задачи.</span></p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Проверка стека во время выполнения (run time) - обзор</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">FreeRTOS предоставляет два опциональных механизма проверки переполнения стека во время выполнения. Поведение механизма определяется константой времени компиляции <span style=" font-weight:600;">configCHECK_FOR_STACK_OVERFLOW</span>, размещенной в файле <span style=" font-weight:600;">FreeRTOSConfig.h</span>. Оба метода увеличивают время, которое тратится на переключение контекста.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хук переполнения стека (или callback) является функцией, которая будет вызвана ядром, когда было детектировано переполнение стека. Чтобы можно было использовать хук переполнения стека, нужно:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· Установить константу configCHECK_FOR_STACK_OVERFLOW либо в значение 1, либо в значение 2 (как обычно, в файле FreeRTOSConfig.h).<br />· Предоставить реализацию функции хука, используя точно такое имя и прототип, как показано ниже.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vApplicationStackOverflowHook( xTaskHandle *pxTask, signed portCHAR *pcTaskName );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хук переполнения стека позволяет проще отлавливать и отлаживать ошибки стека, однако не предоставляет возможности восстановления из переполнения стека, если оно вдруг произошло. Параметры хука передают хендл и имя задачи, у которой будет отслеживаться переполнение в функции хука, так как возможно, что переполнение стека испортит имя задачи, которое было указано при её создании.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хук переполнения стека будет вызван из контекста прерывания.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Некоторые микроконтроллеры будут генерировать исключение отказа, когда они детектировали некорректный доступ к памяти, и возможно, что данное исключение сработает еще раньше, чем ядро получит шанс вызвать функцию хука переполнения стека.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Проверка стека во время выполнения - метод 1</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Метод 1 используется, когда configCHECK_FOR_STACK_OVERFLOW установлена в 1.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задачи сохраняют в стеке свой контекст выполнения каждый раз, когда они отдают ресурс процессора другой задаче (или прерыванию). Возможна ситуация, когда использование стека в какой-то момент дойдет до предела. Когда configCHECK_FOR_STACK_OVERFLOW установлена в 1, ядро будет проверять, что указатель стека остался в допустимых пределах пространства стека после того, как контекст был сохранен в стеке. Функция хука переполнения стека будет вызвана тогда, когда указатель стека выйдет за границу допустимого диапазона.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Метод 1 работает быстрее, однако он может не отследить переполнения стека, которые произойдут между сохранениями контекста.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Проверка стека во время выполнения - метод 2</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Метод 2 выполняет другие проверки кроме тех, что делает метод 1. Метод 2 используется, когда configCHECK_FOR_STACK_OVERFLOW установлена в 2.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда задача создается, то её стек заполняется известным значением. Метод 2 просматривает последние 20 байт пространства стека чтобы проверить, не были ли они перезаписаны. Хук переполнения стека запускается тогда, если любой из этих 20 байт окажется измененным.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Метод 2 не такой быстрый, как метод 1, однако он все же относительно быстрый, так как проверяются только 20 байт. Он скорее всего сможет отловить все случаи переполнения стека, хотя иногда возможно (но маловероятно), что некоторое переполнение может быть пропущено.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">6.3. Другие общие источники ошибок</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">	Симптом: добавление простой задачи в демо приводит его к сбою</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Создание задачи требует выделения памяти, полученной из кучи. Многие проекты демо-приложений имеют размер кучи достаточно большим только для создания задач демо, так что после создания других дополнительных задач (а также очередей или семафоров) может не оказаться достаточно свободной памяти в куче.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача ожидания Idle Task создается автоматически, как только вызвана функция vTaskStartScheduler(). Выход из функции vTaskStartScheduler() произойдет только тогда, когда нет достаточного места в куче для создания задачи. Добавление пустого цикла после вызова vTaskStartScheduler() делает такую ошибку доступной для отладки.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Чтобы можно было добавить в демо другие задачи либо увеличьте размер кучи, либо удалите в демо некоторые из имеющихся задач.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">	Симптом: использование API функции внутри прерывания приводит к сбою приложения</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Используйте только те API функции внутри ISR, имя которых оканчивается на &quot;...FromISR()&quot;.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">	Симптом: иногда приложение разрушается внутри обработчика прерывания</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Первое, что нужно проверить - не происходит ли при прерывании переполнения стека.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Методы задания и использования прерываний отличаются между разными портами FreeRTOS и разными компиляторами - так что второе, что нужно проверить - синтаксис, макросы и соглашения вызова, используемые для ISR, полностью соответствуют страничке документации демо, и полностью демонстрируются в ISR самого демо.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если приложение работает на Cortex M3, то убедитесь, что при назначении приоритетов каждому прерыванию было принята во внимание обратная нумерация приоритетов этого микроконтроллера, так что малым числовым уровням приоритета соответствуют высокоуровневые приоритеты прерываний (что может выглядеть не интуитивно понятным). Общей ошибкой бывает случайное назначение прерыванию приоритета, которое используется FreeRTOS API (выше назначенного константой configMAX_SYSCALL_INTERRUPT_PRIORITY).</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">	Симптом: крах шедулера при попытке запустить первую задачу</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если используется микроконтроллер ARM7, то проверьте, что микроконтроллер находится в режиме супервизора (Supervisor) перед вызовом vTaskStartScheduler(). Самый простой способ достичь этого - поместить процессор в режим супервизора внутри стартового кода C, который вызывается до функции main() (так называемый C startup code). Это делается так же, как сконфигурировано в демо-примерах для ARM7.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Шедулер не сможет запуститься, если процессор не будет находится в режиме Supervisor.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">	Симптом: критические секции не могут корректно быть вложены друг в друга</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Не изменяйте биты разрешения прерываний микроконтроллера или флаги приоритетов прерываний с использованием каких-либо методов, отличающихся от вызовов taskENTER_CRITICAL() и taskEXIT_CRITICAL(). Эти макросы сохраняют подсчет глубины вкладывания критических секций, чтобы гарантировать, что прерывания будут разрешены снова, когда полностью развернется вложение секций друг в друга (счетчик вложений не станет равным 0).</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">	Симптом: крах приложения уже перед запуском шедулера</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">ISR, которое могло потенциально вызвать переключение контекста, не должно быть разрешено к выполнению до старта шедулера. То же самое верно для любого ISR, которое делает попытку отправить данные в очередь или поменять семафор. Переключения контекста могут происходить только после старта шедулера.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Многие функции API не могут быть вызваны до старта шедулера. Лучше всего ограничить использование API созданием задач, очередей и семафоров, пока не будет вызвана функция vTaskStartScheduler().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">	Симптом: вызов API функции по время приостановки шедулера вызывает крах приложения</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Шедулер приостанавливается вызовом vTaskSuspendAll() и возобновляет работу вызовом xTaskResumeAll().</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Не делайте вызовы функций API, когда шедулер приостановлен.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-style:italic;">	Симптом: прототип для функции pxPortInitialiseStack() вызывает ошибку компиляции</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Каждый порт требует определения макроса, который обеспечивает включение в сборку корректных заголовочных файлов. Ошибка при компиляции прототипа pxPortInitialiseStack() указывает на то, что установленный макрос не соответствует используемому порту FreeRTOS. Для дополнительной информации см. Дополнение 4.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Создавайте новые приложения на основе предоставленных демо-проектов с требуемым используемым портом FreeRTOS. Таким способом будет обеспечено корректное включение всех заголовков и правильная установка опций компилятора.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></html>