<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'Georgia'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">4.1. Введение</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Имеется потенциальная возможность возникновения конфликта в многозадачной системе, если одна задача начинает получать доступ к ресурсу, но не завершила этот доступ до выхода из состояния <span style=" font-weight:600;">Running</span>. Если задача оставила ресурс в незавершенном состоянии, то доступ к тому же самому ресурсу со стороны другой задачи или прерывания может привести к порче данных или другой аналогичной ошибке.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Вот несколько примеров:</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1. Доступ к периферийным устройствам</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рассмотрим следующий сценарий, когда две задачи пытаются записать данные в LCD (жидкокристаллический дисплей):</p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Выполняется задача A, и начинает запись в LCD строки &quot;Hello world&quot;.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача A вытеснена задачей B после вывода только части строки &quot;Hello w&quot;.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Перед своим входом в состояние Blocked задача B выводит на LCD запрос “Abort, Retry, Fail?”.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача A продолжает выполнение с того места, где она была вытеснена, и завершает вывод остальных символов - “orld”.</li></ul>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Теперь LCD будет отображать испорченную строку “Hello wAbort, Retry, Fail?orld”.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2. Операции Read, Modify, Write (чтение, модификация, запись) </span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 57 показывает строки кода C и соответствующие им операторы ассемблера (архитектура ARM7). Можно видеть, что значение PORTA сначала прочитано из памяти в регистр, модифицировано в регистре, и затем записано обратно в память. Такая стандартная последовательность действий называется операцией Read, Modify, Write.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Скомпилированный код C. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />155: PORTA |= 0x01;<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Полученный в результате компиляции код ассемблера. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />0x00000264 481C LDR R0,[PC,#0x0070]</span><span style=" font-family:'Courier New'; font-size:10pt; color:#339966;">; Получение адреса PORTA</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />0x00000266 6801 LDR R1,[R0,#0x00]  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#339966;">; Чтение значения PORTA в регистр R1</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />0x00000268 2201 MOV R2,#0x01       </span><span style=" font-family:'Courier New'; font-size:10pt; color:#339966;">; Помещение абсолютной константы 1 в регистр R2</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />0x0000026A 4311 ORR R1,R2          </span><span style=" font-family:'Courier New'; font-size:10pt; color:#339966;">; Операция OR R1 (PORTA) со значением R2 (константа 1)</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />0x0000026C 6001 STR R1,[R0,#0x00]  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#339966;">; Сохранение нового значения обратно в PORTA</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Эта последовательность действий является 'не атомарной', поскольку занимает больше одной инструкции до полного завершения, и может быть прервана посередине. Рассмотрим следующий сценарий, когда две задачи пытаются обновить память, привязанную к регистру под именем PORTA:</p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача A загружает в регистр значение из PORTA - это часть операции Read.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача A вытеснена задачей B до того, как задача A завершила части операции Modify и Write.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача B обновила значение PORTA, и затем вошла в состояние Blocked.</li>
<li style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача A продолжила выполнение кода с того места, где она была вытеснена. Она модифицирует копию значения PORTA, которая была ранее сделана операцией чтения (и теперь стала неактуальной из-за задачи B), и затем записывает результат обратно в PORTA.</li></ul>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В результате задача A обновляет и записывает обратно устаревшее, недостоверное значение PORTA. Задача B успела изменить PORTA между получением копии PORTA задачей A и моментом времени, когда задача A изменяет эту свою копию и записывает её обратно в PORTA. В результате задача A перезаписывает модификацию PORTA, которую сделала задача B, и значение PORTA оказывается испорченным.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот пример использует регистр периферии, но тот же самый принцип может быть применен для операций Read, Modify, Write над глобальными переменными приложения.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3. Неатомарный доступ к переменным</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обновление несколько полей в структуре или обновление переменной с размером больше, чем натуральный размер слова архитектуры микроконтроллера (например, обновление 32-битной переменной на 16-битном процессоре) - это все примеры неатомарных операций. Если эта операция будет прервана, то в результате получится потеря или порча данных.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">4. Реентерабельность (reentrant) функции</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция является реентерабельной, если её можно безопасно вызвать из более чем одной задачи, или как из задач, так и из прерываний одновременно.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Каждая задача имеет свой собственный стек и свой собственный набор значений регистров. Если функция не делает попыток доступа к другим данным, кроме как к собственным, выделенным в стеке, или если она сохраняет используемые ею регистры, то она является реентерабельной. Листинг 58 показывает пример реентерабельной функции. Листинг 59 показывает пример функции, которая не является реентерабельной.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 58. Пример реентерабельной (reentrant) функции</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* В функцию передается параметр. Он будет передан либо через стек,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   либо через регистр CPU. В любом случае каждая задача безопасно</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   получает для этой цели собственный стек или собственный набор</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   регистров. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lAddOneHundered( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lVar1 )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Эта переменная находится строго в области действия функции и</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   будет также выделена через стек или регистр, в зависимости от компилятора</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   и уровня оптимизации. Каждая задача или прерывание, которая будет</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   вызвать эту функцию, получит собственную копию переменной lVar2. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lVar2;<br /><br />  lVar2 = lVar1 + 100;<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Чаще всего возвращаемое значение помещается в регистр CPU,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     хотя оно также может быть помещено и в стек. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">return</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lVar2;<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 59. Пример функции, которая не реентерабельна</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* В этом случае lVar1 является глобальной, так что каждая задача, которая</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   вызовет функцию, будет обращаться к одной и той же одной копии<br />   переменной. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lVar1;<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lNonsenseFunction( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Эта переменная статическая (static), поэтому она не выделяется через<br />   стек. Каждая задача, которая вызывает функцию, будет обращаться к одной</span><br /><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   и той же одной копии переменной. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lState = 0;<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">long</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> lReturn;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">switch</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( lState )<br />  {<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">case</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> 0 : lReturn = lVar1 + 10;<br />            lState = 1;<br />            </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">break</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">;<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">case</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> 1 : lReturn = lVar1 + 20;<br />            lState = 0;<br />            </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">break</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">;<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Взаимное исключение (mutual exclusion, mutex)</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Доступ к ресурсу, который является либо общим для задач, либо общим для задач и прерываний, нуждается в управлении с использованием техники 'взаимного исключения' (mutual exclusion), чтобы обеспечить целостность данных в любой момент времени. Цель состоит в том, чтобы обеспечить только для одной задачи эксклюзивное использование общего ресурса, начиная с момента обращения к нему до момента окончания доступа (до возвращения ресурса в непротиворечивое состояние).</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">FreeRTOS предоставляет несколько возможностей, которые можно использовать для реализации взаимного исключения (mutual exclusion), однако самый лучший метод взаимного исключения (когда это возможно) - разработка приложения таким способом, что ресурсы не делаются общими, и к каждому ресурсу получает доступ только одна задача.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">4.2. Критические секции и приостановка шедулера</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Основные понятия по критической секции</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В общем случае критическая секция - это регион кода, окруженный вызовами макросов taskENTER_CRITICAL() и taskEXIT_CRITICAL(), как показано в листинге 60. Критические секции также известны как критические регионы.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Обеспечим, чтобы доступ к регистру PORTA не был прерван, путем помещения</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   кода доступа к нему в критическую секцию. Здесь вход в критическую<br />   секцию. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />taskENTER_CRITICAL();<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Между вызовами макросов taskENTER_CRITICAL() и taskEXIT_CRITICAL()<br />   невозможно</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">переключение на другую задачу. Прерывания все еще могут<br />   быть выполнены на тех портах FreeRTOS, у которых поддерживается<br />   вложенность прерываний, но только для тех прерываний, у которых<br />   приоритет установлен больше назначенного значения константы<br />   configMAX_SYSCALL_INTERRUPT_PRIORITY –</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">и таким прерываниям не<br />   разрешено вызывать функции API FreeRTOS. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />PORTA |= 0x01;<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Мы закончили доступ к PORTA, и теперь можно покинуть критическую<br />   секцию. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />taskEXIT_CRITICAL();</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Проекты примеров, которые сопровождают эту книгу, используют функцию под названием vPrintString(), чтобы вывести строки на стандартный вывод - такой как окно терминала для выполняемых приложений Open Watcom DOS. Функция vPrintString() вызывается из многих различных задач, так что в теории её реализация должна использовать защиту доступа к стандартному выводу с использованием критической секции, как показано в листинге 61.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> portCHAR *pcString )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Запись строки в stdout, с использованием критической секции как</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     грубого метода взаимного исключения. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  taskENTER_CRITICAL();<br />  {<br />     printf( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;%s&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, pcString );<br />     fflush( stdout );<br />  }<br />  taskEXIT_CRITICAL();<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Разрешаем нажатием любой кнопки остановить приложение. Обычно<br />     приложение</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">использует для этого специальную комбинацию клавиш (типа<br />     Alt+X), что</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">также должно защитить доступ к клавиатурному вводу. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( kbhit() )<br />  {<br />     vTaskEndScheduler();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Критические секции, реализованные таким способом, являются очень грубым методом обеспечения взаимного исключения. Они работают просто путем запрета прерываний либо полностью, либо до уровня приоритета прерываний, установленного константой configMAX_SYSCALL_INTERRUPT_PRIORITY - в зависимости от используемого порта FreeRTOS. Вытесняющее переключение контекста может произойти только изнутри прерывания, так что пока прерывания запрещены, задача вызвавшая taskENTER_CRITICAL() гарантированно останется в состоянии Running до выхода из критической секции.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Критические секции должны быть удержаны как можно более короткими, потому что иначе они повлияют на время ответа на прерывание. Каждый вызов taskENTER_CRITICAL() должен быть полностью парным с вызовом taskEXIT_CRITICAL(). По этой причине стандартный вывод не должен быть защищен с использованием критической секции (как показано в листинге 61), потому что запись в терминал может быть относительно долгой операцией. Также эмулятор DOS и поддержка вывода терминала Open Watcom не совместимы с этой формой взаимного исключения, так как вызовы библиотеки оставляют прерывания разрешенными. Примеры в этой части рассматривают альтернативные решения этой проблемы.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Критические секции безопасны для взаимного вкладывания, потому что ядро подсчитывает глубину вложения. Выход из критической секции произойдет только тогда, когда глубина вложения вернется к нулю - только когда один вызов taskEXIT_CRITICAL() выполняется с предшествующим ему вызовом taskENTER_CRITICAL().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Приостановка (или, иначе говоря, блокировка) шедулера</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Критические секции могут быть также созданы приостановкой шедулера. Приостановка шедулера иногда также известна как 'блокировка' шедулера.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обычно критические секции защищают область кода от доступа со стороны других задач и прерываний. Критическая секция, реализованная путем приостановки шедулера, защищает область кода только от доступа других задач, прерывания при этом останутся разрешенными.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Критическая секция, которая слишком длинная для реализации путем запрета прерываний, может вместо этого быть реализована путем приостановки шедулера, однако возобновление (отмена приостановки) шедулера может быть потенциально относительно долгой операцией, так что для каждого случая нужно тщательно проанализировать, какой метод лучше использовать.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">vTaskSuspendAll()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">portBASE_TYPE xTaskResumeAll( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Шедулер прекращает приостановку (возобновляет работу) после вызова xTaskResumeAll().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Возвращаемое значение</span><br /></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание</span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Переключения контекста, которые запрашивались во время приостановки шедулера, были удержаны в ожидании, и будут выполнены, как только шедулер возобновит работу. Ожидающий переключения контекст был выполнен до возврата xTaskResumeAll(), если функция вернула pdTRUE. Во всех остальных случаях xTaskResumeAll() вернет pdFALSE.</span></p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Можно безопасно делать вложенные друг в друга вызовы vTaskSuspendAll() и xTaskResumeAll(), потому что ядро подсчитывает глубину вложений. Шедулер возобновит работу только тогда, когда счетчик глубины вложений вернется к нулю - гарантия того, что каждый вызов xTaskResumeAll() был обязательно после вызова vTaskSuspendAll().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 64 показывает реальную реализацию vPrintString(), которая приостанавливает шедулер для защиты доступа к выводу на терминал.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> portCHAR *pcString )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Запись строки в stdout, с приостановкой шедулера</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     в качестве метода взаимного исключения. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  vTaskSuspendScheduler();<br />  {<br />     printf( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;%s&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, pcString );<br />     fflush( stdout );<br />  }<br />  xTaskResumeScheduler();<br /> <br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Разрешаем нажатием любой кнопки остановить приложение. Обычно<br />     приложение</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">использует для этого специальную комбинацию клавиш (типа<br />     Alt+X), что</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">также должно защитить доступ к клавиатурному вводу. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( kbhit() )<br />  {<br />     vTaskEndScheduler();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">4.3. Мьютексы (и двоичные семафоры)</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Мьютекс - это специальный тип двоичного семафора, который используется для управлением доступа к ресурсу, который используется совместно двумя или большим количеством задач. Слово MUTEX произошло от &quot;MUTual EXclusion&quot; (взаимное исключение).</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Когда используется сценарий взаимного исключения, мьютекс можно концептуально рассмотреть как токен, связанный с совместно используемым ресурсом. Для законного доступа к ресурсу задача должна сначала 'взять' токен (стать держателем токена). Когда задача - держатель токена завершила работу с ресурсом, она должна 'отдать' токен обратно. Только когда токен свободен, другая задача может взять токен и тогда получить доступ к общему ресурсу. Задаче не разрешено обращаться к общему ресурсу, за исключением того случая, когда она держит токен. Этот механизм показан на рисунке 36.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Несмотря на то, что мьютексы и семафоры имеют много общих характеристик, сценарий на рисунке 36 (где мьютексы используется для взаимного исключения) полностью отличается от сценария рисунка 30 (где двоичные семафоры используются для синхронизации). Главное отличие - в том, что происходит с семафором после того, как он был получен:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">· Семафор, который используется для взаимного исключения, должен быть всегда возвращен.<br />· Семафор, который используется для синхронизации нормально отбрасывается и не возвращается.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image21846.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image17443.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image27931.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image24286.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image31320.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image15604.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 36. Взаимное исключение, реализованное с использованием мьютекса</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Механизм работает только по инициативе разработчика приложения. Нет никаких причин, почему бы задаче не получить доступ к ресурсу в любой момент, однако каждая задача &quot;подчиняется&quot; правилу доступа, что она обязательно должна сначала стать держателем мьютекса.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">API функция <span style=" font-weight:600;">xSemaphoreCreateMutex()</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Мьютекс является типом семафора. Хендлы к различным типам семафоров FreeRTOS сохраняются в переменной типа xSemaphoreHandle.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Перед тем, как мьютекс может быть реально использован, он сначала должен быть создан. Для создания семафора типа мьютекс используется API функция xSemaphoreCreateMutex().</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">xSemaphoreHandle xSemaphoreCreateMutex( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Возвращаемое значение<br /></span></p></td>
<td bgcolor="#0000ff">
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600; color:#ffffff;">Описание<br /></span></p></td></tr>
<tr>
<td bgcolor="#ccffff">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ccffff;">Возвращаемое значение</span></p></td>
<td bgcolor="#ccffff">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если возвращен NULL, то мьютекс не может быть создан из-за недостатка памяти в куче (heap), так как FreeRTOS должна взять оттуда память для структур данных мьютекса. Часть 5 предоставляет больше информации по управлению памятью.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Ненулевое возвращенное значение показывает, что мьютекс был успешно создан. Возвращенное значение должно быть сохранено как хендл к созданному мьютексу (для последующего использования в вызовах API функций).</p></td></tr></table>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Пример 15. Написание заново функции vPrintString() для использования семафора</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот пример создает новую версию функции vPrintString() под именем prvNewPrintString(). В примере вызывается новая функция prvNewPrintString() из нескольких задач. Функция prvNewPrintString() функционально идентична vPrintString(), но использует мьютекс для управления доступом к стандартному выводу вместо обычной критической секции. Реализация prvNewPrintString() показана в листинге 66.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> prvNewPrintString( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">const</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> portCHAR *pcString )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Мьютекс, созданный до старта шедулера, уже существует в момент</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     первого запуска этой задачи.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     Попытка взять мьютекс, с бесконечной блокировкой в ожидании доступности</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     мьютекса, если он пока недоступен. Выход из xSemaphoreTake() произойдет</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     только тогда, когда мьютекс успешно получен, так что нет необходимости</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     проверять результат возврата функции. Если используется любой другой</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     период задержки, то код должен проверить, что xSemaphoreTake() вернула</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     pdTRUE перед доступом к общему ресурсу (который в нашем случае<br />     является</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">стандартным выводом). */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xSemaphoreTake( xMutex, portMAX_DELAY );<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Следующая строка будет только выполняться только тогда, когда<br />        мьютекс был успешно получен. Стандартный вывод может быть<br />        использован свободно, так как теперь в любой момент времени мьютекс<br />        может иметь только одна задача. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     printf( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;%s&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, pcString );<br />     fflush( stdout );<br />     <br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Мьютекс ДОЛЖЕН быть возвращен обратно! */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  }<br />  xSemaphoreGive( xMutex );<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Разрешаем нажатием любой кнопки остановить приложение. Обычно<br />     приложение использует для этого специальную комбинацию клавиш (типа<br />     Alt+X), что</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">также должно защитить доступ к клавиатурному вводу.<br />     Хотя реальное приложение</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">вряд ли будет иметь несколько задач, которые<br />     обрабатывают нажатия клавиш! */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( kbhit() )<br />  {<br />     vTaskEndScheduler();<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция prvNewPrintString() постоянно вызывается двумя экземплярами задачи под названием prvPrintTask(). Между вызовами используется случайное время задержки. Параметр задачи используется для передачи уникальной строки в каждый экземпляр задачи. Реализация prvPrintTask() показана в листинге 67.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> prvPrintTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pcStringToPrint;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Созданы два экземпляра этой задачи, так что строка, которую задача</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     посылает функции prvNewPrintString(), передается, как обычно,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     через параметр задачи. Здесь используется приведение параметра</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     к нужному типу. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  pcStringToPrint = ( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * ) pvParameters;<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Вывод на печать строки с использованием новой функции. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     prvNewPrintString( pcStringToPrint );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Ожидание в течение псевдослучайного времени. Имейте в виду, что<br />        rand()</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">необязательно бывает реентерабельной, но в нашем случае<br />        это неважно,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">так как код не заботится о возвращаемой величине.<br />        В других, более</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">надежных приложениях нужно использовать<br />        реентерабельную версию rand(), или вызовы rand() должны быть<br />        защищены критической секцией. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskDelay( ( rand() &amp; 0x1FF ) );<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Как обычно, функция main() просто создает мьютекс, создает задачи, и запускает шедулер. Реализация показана в листинге 68.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Два экземпляра prvPrintTask() создаются с разными приоритетами, так чтобы задача с меньшим приоритетом могла быть вытеснена задачей с более высоким приоритетом. Мьютекс используется для того, чтобы обеспечить взаимоисключающий доступ каждой задачи к выводу на терминал, даже когда одна задача вытеснена другой - выводимые строки будут отображаться корректно и не будут испорчены. Частота вытеснений может быть повышена путем уменьшения максимального времени нахождения задач в состоянии Blocked, которое по умолчанию установлено в значение 0x1FF тиков.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> main( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Перед тем, как семафор может использоваться, он должен быть явным</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     образом создан. В этом примере создается семафор типа мьютекс. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xMutex = xSemaphoreCreateMutex();<br /> <br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Задачи используют псевдослучайную задержку, инициализация генератора</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     случайного числа. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  srand( 567 );<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Перед созданием задач проверим, что семафор создан успешно. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xMutex != NULL )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание двух экземпляров задач, которые пишут в stdout. Строка,<br />        которую</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">они пишут, передается через параметр задачи. Задачи<br />        создаются с разным</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">приоритетом, чтобы могло произойти<br />        вытеснение одной задачи другой задачей. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( prvPrintTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Print1&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000,<br />                  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Task 1 ******************************************\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">,<br />                  1, NULL );<br />     xTaskCreate( prvPrintTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Print2&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000,<br />                  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Task 2 ------------------------------------------\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">,<br />                  2, NULL );<br /> <br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Запуск шедулера, после чего задачи запустятся на выполнение. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskStartScheduler();<br />  }<br /> <br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Если все хорошо, то управление в main() никогда не дойдет до этой<br />     точки,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">и теперь шедулер будет управлять задачами. Если main() довела<br />     управление до этого места, то это может означать, что не хватает<br />     памяти кучи (heap) для создания специальной задачи ожидания (idle<br />     task).</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Часть 5 предоставляет больше информации по управлению<br />     памятью. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; );<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Вывод, производимый примером 15, показан на рисунке 37. Возможная последовательность выполнения описана на рисунке 38.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image21636.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">На рисунке 37 видно, что как и ожидалось, строки выводятся на терминал без искажений. Случайный порядок строк - результат случайного периода задержки, используемого задачами.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image9890.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 38. Возможная последовательность выполнения для примера 15</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Инверсия приоритета</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рисунок 38 демонстрирует одну потенциальную ловушку, в которую можно попасть, используя мьютекс для обеспечения взаимного исключения. Рассмотренная последовательность выполнения показывает, что задача 2 с более высоким приоритетом ждет низкоприоритетную задачу 1, чтобы получить контроль над мьютексом. Такой случай, когда выполнение высокоприоритетной задачи откладывается низкоприоритетной задачей, называется 'инверсией приоритета' (priority inversion). Это нежелательное поведение может быть еще более ухудшено, если запустится задача со средним приоритетом в то время, как высокоприоритетная задача ждет семафор - в результате получится, что высокоприоритетная задача ждет низкоприоритетную задачу, когда низкоприоритетная задача даже не имеет возможности запуститься! Такой наихудший сценарий показан на рисунке 39.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1651.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 39. Наихудший возможный сценарий инверсии приоритетов<br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Инверсия приоритета может быть очень серьезной проблемой, но в малых встраиваемых системах её часто можно избежать путем тщательного планирования доступа к ресурсам во время разработки системы.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Наследование приоритета</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Мьютексы и двоичные семафоры FreeRTOS очень просты, и различаются друг от друга только тем, что мьютексы предоставляют базовый механизм 'наследования приоритета'. Наследование приоритета - схема, которая минимизирует негативный эффект от инверсии приоритета. Наследование приоритета не 'исправляет' инверсию приоритета, а просто значительно снижает её воздействие. Применение наследования приоритета делает математический анализ поведения системы более сложным, поэтому не рекомендуется использовать наследование приоритета, если этого можно как-то избежать.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Наследование приоритета работает через временное повышение приоритета держателя мьютекса до приоритета задачи с самым высоким приоритетом, которая пытается получить тот же самый мьютекс. Низкоприоритетная задача, которая удерживает мьютекс, 'наследует' приоритет задачи, которая ждет мьютекс. Это демонстрируется на рисунке 40. Приоритет держателя мьютекса автоматически сбрасывается обратно в свое исходное значение, когда держатель мьютекса возвращает мьютекс обратно.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image18193.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рис. 40. Наследование приоритета минимизирует эффект от инверсии приоритета.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Поскольку, во-первых, необходимо избегать инверсии приоритета, и поскольку, во-вторых, FreeRTOS предназначена для микроконтроллеров с ограниченными ресурсами памяти, механизм наследования приоритетов реализован мьютексами только в базовой форме, которая подразумевает, что задача в каждый момент времени удерживает только один мьютекс.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Глухая блокировка, deadlock (или &quot;мертвые объятия&quot;)</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">'Deadlock' - другая потенциальная ловушка в использовании мьютексов для взаимного исключения. Deadlock иногда известен под более драматическим именем 'смертельные объятия'.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Deadlock произойдет, когда две задачи не могут работать, поскольку они обе ждут ресурса, который удерживается третьей задачей. Представим себе следующий сценарий, где задача A и задача B обе хотят получить мьютекс X и мьютекс Y в следующем порядке действий:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1</span>. Задача A выполняется и успешно получает мьютекс X.<br /><span style=" font-weight:600;">2</span>. Задача A вытесняется задачей B.<br /><span style=" font-weight:600;">3</span>. Задача B успешно получила мьютекс Y перед попыткой получить мьютекс X - однако мьютекс X удерживается задачей A, и поэтому недоступен для задачи B. Задача B решает войти в состояние Blocked для ожидания освобождения мьютекса X.<br /><span style=" font-weight:600;">4</span>. Задача A продолжает выполнение. Она пытается получить мьютекс Y - но мьютекс Y удерживается задачей B, и поэтому недоступен для задачи A. Задача A решает войти в состояние Blocked для ожидания освобождения мьютекса Y.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В конце этого сценария задача A ждет мьютекса, удерживаемого задачей B, а задача B ждет мьютекса, удерживаемого задачей A. Deadlock произошел, потому что ни одна из задач дальше не может выполняться.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Как и с инверсией приоритетов, наилучший метод избежать деадлока - рассмотреть такую возможность на этапе разработки приложения, и разработать систему так, чтобы такая ситуация в принципе не смогла бы возникнуть. На практике деадлок небольшая проблема для малых встраиваемых систем, поскольку их разработчики могут иметь хорошее понимание работы всего приложения в целом, и могут быстро идентифицировать и устранить проблему, где она возникает.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">4.4. Задачи привратника (GATEKEEPER)</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задачи гейткипера предоставляют чистый метод реализации взаимного исключения без всякого беспокойства о инверсии приоритета или деадлоке.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача гейткипера - это задача, единолично владеющая ресурсом. Только задача гейткипера может напрямую получить доступ к ресурсу - любая другая задача, нуждающаяся в доступе к ресурсу, может это делать только косвенно, используя службы гейткипера.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">Пример 16. Написание заново функции vPrintString() для использования задачи гейткипера</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Пример 16 также предоставляет альтернативную реализацию vPrintString(), на этот раз используется задача гейткипера для получения доступа к стандартному выводу. Когда задача хочет записать сообщение в терминал, она не использует напрямую функцию печати, но вместо этого отправляет сообщение привратнику.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Гейткипер использует очередь FreeRTOS для организации последовательного доступа к терминалу. Внутренней реализации задачи не требуется взаимное исключение, так как только одна задача может обращаться к терминалу напрямую.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача гейткипера почти все свое время проводит в состоянии Blocked, ожидая появления сообщений на очереди. Когда сообщение поступило в очередь, гейткипер просто выводит его в stdout перед возвратом в состояние Blocked для ожидания следующего сообщения. Реализация задачи гейткипера показана в листинге 70.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прерывания могут отправить данные в очередь, так что ISR могут безопасно использовать службы гейткипера для вывода сообщений в терминал. В этом примере используется функция хука тиков для вывода сообщения каждые 200 тиков.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хук тиков (или callback) - функия, которая вызывается ядром во время каждого прерывания тика. Для использования функции хука тика нужно:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">	· Установить configUSE_TICK_HOOK в 1 в файле FreeRTOSConfig.h.<br />	· Предоставить реализацию функции хука тика, используя точно такое имя и прототип функции, как показано в листинге 69.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 69. Имя и прототип для функции хука тиков (tick hook):</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vApplicationTickHook( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> );</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функции хука тика исполняются в контексте прерывания тика, так что она должна быть как можно проще и короче, использовать только управляемое пространство стека, и не должна вызывать никакие функции API FreeRTOS, имя которых не оканчивается на 'FromISR()'.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Листинг 70. Задача привратника (gatekeeper):</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> prvStdioGatekeeperTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pcMessageToPrint;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Только этой задаче привратника разрешено записывать в окно<br />     терминала.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Все другие задачи, которым надо вывести что-то на<br />     терминал, не получают</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">прямой доступ к терминалу, но вместо<br />     этого отправляют строку привратнику.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Так как только эта задача<br />     пишет в stdout, не нужно заботиться о взаимном исключении или<br />     сериализации внутри этой задачи. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Ожидание поступления сообщения. Указывается бесконечное<br />        время блокировки,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">так что не надо проверять значение<br />        возврата - выход из xQueueReceive()</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">произойдет только<br />        тогда, когда будет успешно получено сообщение. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xQueueReceive( xPrintQueue, &amp;pcMessageToPrint, portMAX_DELAY );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Вывод принятой строки. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     printf( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;%s&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, pcMessageToPrint );<br />     fflush( stdout );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Теперь просто происходит возврат к ожиданию следующего<br />        сообщения. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача, которая выводит сообщение, сделана так же, как в примере 15, за исключением того, что на этот раз строка отправляется в очередь гейткипера, а не выводится напрямую. Реализация задачи показана в листинге 71. Как и в прошлый раз, создаются два разных экземпляра одной и той же задачи, каждый из экземпляров печатает свою уникальную строку, переданную через параметр задачи.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> prvPrintTask( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pvParameters )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> iIndexToString;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создается два экземпляра этой задачи. Параметр задачи<br />     используется для передачи в задачу индекса строки в массиве.<br />     Здесь делается приведение к нужному типу. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  iIndexToString = ( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> ) pvParameters;<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Вывод на печать строки - не напрямую, а вместо этого<br />        передача указателя</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">на строку привратнику через очередь.<br />        Очередь создается перед запуском шедулера, так что очередь<br />        уже существует перед первым запуском этой задачи. Время<br />        блокировки не указано, так как в очереди всегда должно<br />        быть свободное место. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xQueueSendToBack( xPrintQueue, &amp;( pcStringsToPrint[ iIndexToString ] ), 0 );<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Ожидание в течение псевдослучайного времени. Имейте в виду,<br />        что rand() необязательно бывает реентерабельной, но в нашем<br />        случае это неважно, так как код не заботится о возвращаемой<br />        величине. В других, более надежных приложениях нужно<br />        использовать реентерабельную версию rand(), или вызовы<br />        rand() должны быть защищены критической секцией. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskDelay( ( rand() &amp; 0x1FF ) );<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Функция хука тиков просто считает количество её вызовов, отправляя свое сообщение задаче гейткипера, как только счетчик достигнет 200. Только в целях демонстрации хук тика пишет в начало очереди, и задача prvPrintTask пишет в конец очереди. Реализация хука тиков показана в листинге 72.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> vApplicationTickHook( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> iCount = 0;<br />portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Вывод на печать сообщения каждые 200 тиков. Сообщение не выводится</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     напрямую, оно отправляется задаче гейткипера. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  iCount++;<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( iCount &gt;= 200 )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* В этом случае последний параметр (xHigherPriorityTaskWoken) реально</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        не используется, однако все равно должен быть предоставлен. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xQueueSendToFrontFromISR( xPrintQueue,<br />                                &amp;( pcStringsToPrint[ 2 ] ),<br />                                &amp;xHigherPriorityTaskWoken );<br />                              <br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Сброс счетчика, чтобы печать сообщения происходила каждые 200 тиков</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        времени. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     iCount = 0;<br />  }<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Как обычно, функция main() просто создает очередь и задачи, необходимые для работы примера, и затем запускает шедулер. Реализация main() показана в листинге 73.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Определение строк, которые будут выводить на печать задачи</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   и прерывание через гейткипера. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">static</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> *pcStringsToPrint[] =<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Task 1 ****************************************************\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">,<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Task 2 ----------------------------------------------------\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">,<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Message printed from the tick hook interrupt ##############\r\n&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />};<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/*-----------------------------------------------------------*/</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Декларирование переменной типа xQueueHandle. Она используется</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   для отправки сообщений из задач печати и прерывания тика</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">   в задачу гейткипера. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />xQueueHandle xPrintQueue;<br /><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/*-----------------------------------------------------------*/</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">int</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> main( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> )<br />{<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Перед использованием очереди она должна быть явно создана.</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     Очередь создается для удержания в себе максимум 5</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     указателей на строку. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  xPrintQueue = xQueueCreate( 5, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">sizeof</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">char</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * ) );<br /> <br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Задачи используют псевдослучайную задержку, инициализируем</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">     генератора случайных чисел. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  srand( 567 );<br /><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Проверка: успешно ли создана очередь. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">if</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( xPrintQueue != NULL )<br />  {<br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание двух экземпляров задач, которые отправляют сообщения</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        гейткиперу. Для передачи индекса печатаемой строки используется</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        параметр задачи (4-й параметр xTaskCreate()). Задачи создаются</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        с разным приоритетом, так что случайным образом низкоприоритетная</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        задача будет вытесняться высокоприоритетной задачей. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( prvPrintTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Print1&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, ( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * ) 0, 1, NULL );<br />     xTaskCreate( prvPrintTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Print2&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, ( </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">void</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> * ) 1, 2, NULL );<br />     <br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Создание задачи гейткипера. Только этой задаче разрешен прямой</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br /></span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">        доступ к стандартному выводу. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     xTaskCreate( prvStdioGatekeeperTask, </span><span style=" font-family:'Courier New'; font-size:10pt; color:#a31515;">&quot;Gatekeeper&quot;</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">, 1000, NULL, 0, NULL );<br />     <br />     </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Запуск шедулера, так что созданные задачи могут запуститься. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />     vTaskStartScheduler();<br />  }<br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">/* Если все хорошо, то управление в main() никогда не дойдет до<br />     этой точки,</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">и теперь шедулер будет управлять задачами. Если<br />     main() довела управление до этого места, то это может<br />     означать, что не хватает памяти кучи (heap)</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">для создания<br />     специальной задачи ожидания (idle task).</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"> </span><span style=" font-family:'Courier New'; font-size:10pt; color:#008000;">Часть 5 предоставляет<br />     больше информации по управлению памятью. */</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;"><br />  </span><span style=" font-family:'Courier New'; font-size:10pt; color:#0000ff;">for</span><span style=" font-family:'Courier New'; font-size:10pt; color:#000000;">( ;; );<br />}</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Вывод, производимый примером 16, показан на рисунке 41. Как можно видеть, строки, приходящие из задач, и строки, приходящие из прерывания, все выводятся корректно, без порчи своего содержимого.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image11541.png" /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Задача привратника получила приоритет меньше, чем приоритеты печатающих задач - так что сообщения, которые отправлены гейткиперу, остаются в очереди, пока обе задачи печати не были в состоянии Blocked. В некоторых ситуациях может потребоваться назначить привратнику более высокий приоритет, чтобы сообщения были обработаны быстрее - но сделать так означает, что привратник будет задерживать выполнение менее приоритетных задач, пока он не завершит доступ к защищенному ресурсу.</p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></html>